<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>OBR-FIELD-UNIT V5.18</title> <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=Orbitron:wght@500;700&display=swap" rel="stylesheet">
    
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-core"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-converter"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgl"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection"></script>

    <style>
        :root {
            --glow-color: #00FFFF; 
            --panel-bg: #1a1a1a; 
            --neon-green: #39FF14; 
            --alert-red: #FF3333;
            --amber-light: rgba(255, 176, 0, 0.1);
            --led-blue: #0055FF;
            --led-yellow: #FFCC00;
        }
        
        body {
            font-family: 'Share Tech Mono', monospace;
            background-color: #000;
            color: var(--glow-color);
            overflow: hidden;
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #bg-camera-feed {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover; 
            z-index: 0;
            filter: brightness(0.8);
            transform: scaleX(1); 
            transition: all 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }
        
        /* Zoom Out (Estilo .5) */
        body.panels-active #bg-camera-feed {
            object-fit: contain; 
            transform: scale(0.55); /* (V5.17) */
            filter: brightness(0.4);
            background-color: #000;
        }

        #ui-container {
            position: relative;
            width: 100%;
            height: 100%;
            z-index: 10;
            display: flex;
            flex-direction: column;
            justify-content: flex-end; 
            padding: 10px;
            box-sizing: border-box;
            pointer-events: none; 
        }

        .header-title {
            position: absolute;
            top: 0; 
            left: 0; 
            width: 100%;
            text-align: center;
            font-family: 'Orbitron', sans-serif;
            font-size: 0.9rem;
            font-weight: 700;
            color: rgba(0, 255, 255, 0.8);
            text-shadow: 0 0 5px var(--glow-color);
            letter-spacing: 3px;
            background: linear-gradient(to bottom, rgba(0,0,0,0.9), transparent);
            padding: 15px 0;
            pointer-events: auto;
            animation: breatheSlow 20s infinite ease-in-out; 
            z-index: 20;
            opacity: 0; 
        }
        
        @keyframes breatheSlow {
            0%, 80% { opacity: 0; } 
            90% { opacity: 0.7; text-shadow: 0 0 10px var(--glow-color); }
            100% { opacity: 0; }
        }

        .panels-grid {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 8px;
            width: 100%;
            max-height: 35vh; 
            pointer-events: auto;
            transition: opacity 0.3s;
            padding-bottom: 5px;
        }

        .panel {
            background: repeating-linear-gradient(135deg, #1a1a1a, #1a1a1a 10px, #222 10px, #222 12px);
            border: 1px solid #444;
            border-top: 1px solid #666;
            border-bottom: 1px solid #000;
            border-radius: 8px;
            box-shadow: inset 0 0 20px #000, 0 5px 15px rgba(0,0,0,0.8);
            display: flex;
            flex-direction: column;
            padding: 8px;
            position: relative;
            overflow: hidden;
            transition: box-shadow 0.3s ease;
        }
        
        .panel.alert {
            box-shadow: inset 0 0 20px #000, 0 5px 15px rgba(0,0,0,0.8), 0 0 20px var(--alert-red);
            border-color: var(--alert-red);
        }
        
        .panel::before, .panel::after {
            content: ''; position: absolute; top: 5px; width: 6px; height: 6px;
            background: radial-gradient(circle, #555, #111);
            border-radius: 50%; box-shadow: 0 1px 0 rgba(255,255,255,0.2);
        }
        .panel::before { left: 5px; }
        .panel::after { right: 5px; }

        #p-detector.retro-lit::before {
            content: ''; position: absolute; top:0; left:0; width:100%; height:100%;
            background: radial-gradient(circle at center, var(--amber-light), transparent 80%);
            pointer-events: none; z-index: 0; animation: flicker 0.1s infinite;
        }
        @keyframes flicker { 0% { opacity: 0.95; } 100% { opacity: 1; } }
        
        .panel.hidden { display: none; }

        .panel-header {
            font-size: 0.6rem; text-align: center; margin-bottom: 5px; color: #888;
            text-shadow: 0 -1px 0 #000; border-bottom: 2px groove #333; padding-bottom: 2px;
            text-transform: uppercase; letter-spacing: 1px; background: rgba(0,0,0,0.3);
            border-radius: 4px; z-index: 1;
        }

        /* --- PANEL 1: CÁMARA --- */
        .camera-view-box {
            flex-grow: 1; background: #050505; border: 2px inset #333; border-radius: 4px;
            position: relative; overflow: hidden; margin-bottom: 5px; z-index: 1;
        }
        
        #ghosttube-canvas { 
            width: 100%; height: 100%; 
            object-fit: contain; 
        }
        
        .camera-controls {
            display: flex; justify-content: space-between; gap: 4px; z-index: 1;
        }
        
        .cam-btn {
            background: linear-gradient(to bottom, #333, #1a1a1a); border: 1px solid #444;
            color: #00aaaa; 
            font-size: 0.65rem; 
            border-radius: 2px; cursor: pointer;
            flex: 1; display: flex; align-items: center; justify-content: center;
            box-shadow: 0 2px 0 #000;
            height: 40px; 
            padding: 5px 2px; 
        }
        .cam-btn:active { transform: translateY(2px); box-shadow: none; }
        .cam-btn.active {
            background: #003333; color: var(--glow-color); border-color: var(--glow-color);
            box-shadow: inset 0 0 5px var(--glow-color);
        }

        /* --- PANEL 2: DETECTOR --- */
        .emf-container {
            display: flex; flex-direction: column; height: 100%; justify-content: space-between; z-index: 1;
        }
        
        .vu-section {
            display: flex; justify-content: space-between; margin-bottom: 5px; gap: 5px; height: 15px;
        }
        .vu-box {
            flex: 1; background: #111; border: 1px inset #444; position: relative; overflow: hidden;
        }
        .vu-bar-fill {
            height: 100%; width: 0%; opacity: 0.9; transition: width 0.05s linear;
            box-shadow: 0 0 5px #0f0, 0 0 10px #ff0;
        }
        #vu-l {
            background: linear-gradient(to right, #00ff00, #ffff00, #ff0000);
            float: left;
        }
        #vu-r {
            background: linear-gradient(to left, #00ff00, #ffff00, #ff0000);
            float: right;
        }

        .meter-section {
            flex-grow: 1; position: relative;
            background: 
                linear-gradient(90deg, transparent 49%, rgba(0,255,255,0.1) 50%, transparent 51%),
                repeating-linear-gradient(90deg, transparent, transparent 19px, rgba(255,255,255,0.05) 20px),
                radial-gradient(circle at 50% 100%, #222, #000);
            border: 1px solid #333; border-radius: 4px; margin-bottom: 5px;
            box-shadow: inset 0 0 10px #000;
        }
        .meter-freqs {
            position: absolute; top: 5px; left: 0; width: 100%; text-align: center;
            font-size: 0.45rem; color: #555; z-index: 1; display: flex; justify-content: space-between; padding: 0 10px;
        }
        
        #main-needle {
            width: 2px; height: 85%; background: #ff5500; position: absolute;
            bottom: 0; left: 50%; transform-origin: bottom center; transform: rotate(-45deg);
            transition: transform 0.1s cubic-bezier(0.2, 1.5, 0.5, 1);
            box-shadow: 0 0 5px #ff5500; z-index: 2;
        }

        .knobs-section { display: flex; justify-content: space-around; margin-bottom: 5px; }
        
        .knob-circle {
            width: 45px; 
            height: 45px; 
            border-radius: 50%; border: 2px solid #555;
            position: relative; margin: 0 auto 2px auto; cursor: pointer;
            background: conic-gradient(#222, #000, #222); box-shadow: 0 3px 5px #000;
        }
        .knob-circle::after {
            content:''; position:absolute; top:0; left:0; width:100%; height:100%;
            border-radius:50%; background: linear-gradient(135deg, rgba(255,255,255,0.1), transparent);
        }
        .knob-indicator {
            position: absolute; 
            top: 4px; 
            left: 50%; 
            width: 2px; 
            height: 15px; 
            background: #ff5500; transform: translateX(-50%);
        }
        .knob-label { 
            font-size: 0.6rem; 
            color: #aaa; text-align: center; text-shadow: 0 1px 0 #000; 
        }

        .volume-slider-container {
            width: 100%; display: flex; align-items: center; gap: 8px; padding: 5px 0;
        }
        
        input[type=range] {
            flex-grow: 1; -webkit-appearance: none; 
            height: 25px; 
            background: #111;
            border: 1px solid #333; border-radius: 10px; overflow: hidden;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none; 
            width: 35px; 
            height: 35px; 
            background: #444;
            border: 1px solid #666; 
            border-radius: 50%; 
            box-shadow: -100vw 0 0 100vw var(--glow-color);
            cursor: pointer;
        }

        /* --- PANEL 3: AMBIENTE --- */
        .env-content {
            display: flex; flex-direction: column; height: 100%; justify-content: center; 
            align-items: center; padding: 5px 0; z-index: 1; transition: all 0.5s ease;
        }
        
        .temp-readout {
            font-size: 2.5rem; font-weight: bold; color: var(--glow-color);
            text-shadow: 0 0 15px rgba(0,255,255,0.3);
            background: rgba(0,0,0,0.5);
            padding: 15px 25px;
            border: 2px solid #333;
            border-left: 4px solid var(--glow-color); 
            border-radius: 0 10px 10px 0;
            font-family: 'Share Tech Mono', monospace;
            transition: all 0.5s ease;
        }
        .temp-label-small { font-size: 0.6rem; color: #666; margin-top: 5px; }
        
        .energy-container {
            width: 100%; display: flex; flex-direction: column; align-items: center;
            height: 0; opacity: 0; overflow: hidden; transition: all 0.5s ease;
            transform: scaleY(0.5); 
        }
        
        .env-content.active { justify-content: space-between; }
        .env-content.active .temp-readout { font-size: 1.5rem; padding: 5px 15px; border-width: 1px; }
        .env-content.active .energy-container { height: auto; opacity: 1; flex-grow: 1; margin-top: 5px; transform: scaleY(1); }

        .led-bar {
            display: flex; gap: 3px; margin-bottom: 5px;
            background: #000; padding: 4px; border-radius: 4px; border: 1px solid #333;
        }
        .led-segment {
            width: 8px; 
            height: 15px;
            background-color: #111;
            border: 1px solid #222;
            transition: background-color 0.1s;
        }
        .led-segment.active-blue { background-color: var(--led-blue); box-shadow: 0 0 10px var(--led-blue); }
        .led-segment.active-yellow { background-color: var(--led-yellow); box-shadow: 0 0 10px var(--led-yellow); }
        .led-segment.active-red { background-color: var(--alert-red); box-shadow: 0 0 15px var(--alert-red); }


        .energy-label { font-size: 0.6rem; color: #aaa; margin-bottom: 5px; letter-spacing: 1px; }
        
        .energy-graph-box {
            width: 100%;
            height: 100%;
            flex-grow: 1; 
            background: #000;
            border: 1px inset #333;
            border-radius: 5px;
            overflow: hidden;
            margin-top: 5px;
        }
        #energy-canvas {
            width: 100%;
            height: 100%;
        }

        .plate-obr {
            background: linear-gradient(to right, #222, #444, #222); border: 1px solid #000;
            color: #aaa; font-size: 0.6rem; padding: 4px 10px;
            box-shadow: 0 1px 0 rgba(255,255,255,0.1); text-shadow: 0 -1px 0 #000;
            border-radius: 2px; font-weight: bold;
            margin-top: 5px; 
        }

        .status-led {
            width: 10px; height: 10px; 
            background-color: #333;
            border: 1px solid #000;
            border-radius: 50%;
            position: absolute;
            top: 10px; right: 10px;
            transition: all 0.2s;
            box-shadow: inset 0 0 3px #000;
        }
        #p-env .status-led { background-color: #220000; } 
        
        .status-led.active-mic {
            background-color: var(--alert-red);
            box-shadow: 0 0 8px var(--alert-red), 0 0 15px var(--alert-red);
            animation: pulse 1s infinite;
        }
        .status-led.active-sensor {
            background-color: var(--neon-green);
            box-shadow: 0 0 8px var(--neon-green), 0 0 15px var(--neon-green);
        }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }


        /* --- Botón VER --- */
        #btn-ver {
            position: fixed; bottom: 20px; right: 20px; width: 55px; height: 55px;
            border-radius: 50%; border: 2px solid #00aaaa;
            background: radial-gradient(#004444, #002222); color: #00ffff;
            font-weight: bold; font-size: 0.8rem; display: flex; justify-content: center;
            align-items: center; cursor: pointer; box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
            z-index: 100;
        }
        #menu-tools {
            position: fixed; bottom: 85px; right: 20px; background: rgba(10,15,20,0.95);
            border: 1px solid #00aaaa; border-radius: 8px; padding: 5px;
            display: none; z-index: 99;
        }
        #menu-tools.visible { display: block; }
        .menu-item {
            padding: 10px 20px; color: #aaa; border-bottom: 1px solid #333;
            cursor: pointer; font-size: 0.7rem;
        }
        .menu-item.active { 
            color: #00ffff; 
            text-shadow: 0 0 5px #00ffff; 
            background: rgba(0, 255, 255, 0.1);
        }

        #sls-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }

        @media (max-width: 768px) and (orientation: portrait) {
            .panels-grid { 
                grid-template-columns: 1fr; 
                gap: 10px; 
                padding-bottom: 80px; 
                max-height: 70vh; 
                overflow-y: auto; 
            }
            .panel { height: 320px; flex-shrink: 0; } 
        }
    </style>
</head>
<body>

    <video id="bg-camera-feed" playsinline autoplay muted></video>

    <div id="ui-container">
        <div class="header-title">EQUIPO PROFESIONAL DE EXPLORACIONES OBR</div>

        <div class="panels-grid" id="panels-container">

            <div class="panel" id="p-camera">
                <div class="panel-header">FILTROS ESPECTRALES</div>
                <div class="camera-view-box">
                    <canvas id="ghosttube-canvas"></canvas>
                    <svg id="sls-overlay" viewBox="0 0 320 240"></svg>
                </div>
                <div class="camera-controls">
                    <button class="cam-btn active" onclick="setFilter('scanner-diag')">SCANNER-DIAG</button>
                    <button class="cam-btn" onclick="setFilter('sls')">SLS KINECT</button>
                    <button class="cam-btn" onclick="setFilter('relief')">RELIEVE</button>
                </div>
            </div>

            <div class="panel" id="p-detector">
                <div class="panel-header">RADIO-FRECUENCIA</div>
                <div class="status-led" id="mic-led" title="Micrófono Escuchando"></div>
                
                <div class="emf-container">
                    <div class="vu-section">
                        <div class="vu-box"><div id="vu-l" class="vu-bar-fill"></div></div>
                        <div class="vu-box"><div id="vu-r" class="vu-bar-fill"></div></div>
                    </div>
                    <div class="meter-section">
                        <div class="meter-freqs">
                            <span>| 50</span><span>| 100</span><span>| 500</span><span>| 1k</span><span>| 10k |</span>
                        </div>
                        <div id="main-needle"></div>
                    </div>
                    <div class="knobs-section">
                        <div style="text-align:center">
                            <div class="knob-circle" id="knob-power" style="transform: rotate(-135deg);"><div class="knob-indicator"></div></div>
                            <div class="knob-label">POWER</div>
                        </div>
                        <div style="text-align:center">
                            <div class="knob-circle" id="knob-scan" style="transform: rotate(-135deg);"><div class="knob-indicator"></div></div>
                            <div class="knob-label">SCAN</div>
                        </div>
                    </div>
                    <div class="volume-slider-container">
                        <div class="knob-label">VOL</div>
                        <input type="range" min="0" max="100" value="80" id="vol-slider">
                    </div>
                </div>
            </div>

            <div class="panel" id="p-env">
                <div class="panel-header">SENSORES</div>
                <div class="status-led" id="sensor-led" title="Sensor EMF Real Activo"></div>
                
                <div class="env-content" id="env-content-box">
                    <div class="temp-readout" id="temp-val">19.8°C</div>
                    <div class="temp-label-small">TEMP AMBIENTE</div>
                    
                    <div class="energy-container">
                        <div class="energy-label" style="margin-top:10px;">INTENSIDAD DE CAMPO</div>
                        <div class="led-bar">
                            <div class="led-segment" id="seg-1"></div>
                            <div class="led-segment" id="seg-2"></div>
                            <div class="led-segment" id="seg-3"></div>
                            <div class="led-segment" id="seg-4"></div>
                            <div class="led-segment" id="seg-5"></div>
                            <div class="led-segment" id="seg-6"></div>
                            <div class="led-segment" id="seg-7"></div>
                            <div class="led-segment" id="seg-8"></div>
                            <div class="led-segment" id="seg-9"></div>
                            <div class="led-segment" id="seg-10"></div>
                        </div>
                        <div class="energy-graph-box">
                            <canvas id="energy-canvas"></canvas>
                        </div>
                    </div>
                    
                    <div class="plate-obr">OBR-FIELD-UNIT</div> 
                </div>
            </div>

        </div>
    </div>

    <div id="btn-ver">VER</div>
    <div id="menu-tools">
        <div class="menu-item active" id="m-camera" onclick="togglePanel('p-camera')">CÁMARA</div>
        <div class="menu-item active" id="m-detector" onclick="togglePanel('p-detector')">DETECTOR</div>
        <div class="menu-item active" id="m-env" onclick="togglePanel('p-env')">SENSOR</div>
    </div>

    <script>
        const SHEETDB_URL = "https.sheetdb.io/api/v1/9xzfnke69kkej"; 
        let isRunning = false;
        let currentFilter = 'scanner-diag'; 
        let scanSpeed = 0; 
        
        const videoBg = document.getElementById('bg-camera-feed');
        const canvas = document.getElementById('ghosttube-canvas');
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        
        const envContent = document.getElementById('env-content-box');
        const detectorPanel = document.getElementById('p-detector');
        const sensorPanel = document.getElementById('p-env'); 
        const segments = [1,2,3,4,5,6,7,8,9,10].map(i => document.getElementById('seg-'+i));
        const vuL = document.getElementById('vu-l');
        const vuR = document.getElementById('vu-r');
        
        const micLed = document.getElementById('mic-led');
        const sensorLed = document.getElementById('sensor-led');
        
        let energyHistory = new Array(50).fill(0);
        let energyCanvas, energyCtx;
        
        let audioCtx, masterGain, gainNode, lfo, lfoGain, whiteNoiseNode, radioOsc, radioGain, reverb, reverbGain, distortionNode;
        let isSpeaking = false; 
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        let recognition, isRecognizing = false;
        let programadoData = new Map();
        let automaticoData = [];
        let currentTemp = 19.8;
        
        let magnetometer; 
        let emfValue = 0; // Valor 0-100
        let emfSimInterval = null;
        let visualLoopInterval; 

        // SOLUCIÓN 1: Variable para el detector de IA
        let poseDetector;

        async function startCamera() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: { ideal: "environment" }, width: { ideal: 1280 } },
                    audio: false
                });
                videoBg.srcObject = stream;
                videoBg.onloadedmetadata = () => {
                    canvas.width = 320; canvas.height = 240;
                    energyCanvas = document.getElementById('energy-canvas');
                    if (energyCanvas) { 
                        energyCtx = energyCanvas.getContext('2d');
                        resizeEnergyCanvas();
                    }
                    drawLoop(); // Inicia el bucle de dibujo
                };
            } catch (e) { console.log("Error camara", e); }
        }

        // SOLUCIÓN 1: Función para cargar el modelo de IA
        async function initMLModel() {
            try {
                const model = poseDetection.SupportedModels.MoveNet;
                poseDetector = await poseDetection.createDetector(model);
                console.log("MoveNet (IA de Poses) cargado.");
            } catch (e) {
                console.error("Error al cargar modelo de IA:", e);
            }
        }

        let edgeMap = null; 
        let sweepDiagonal = 0; 

        
        // SOLUCIÓN 1: El bucle de dibujo ahora es ASYNC para esperar a la IA
        async function drawLoop() {
            if (videoBg.readyState === videoBg.HAVE_ENOUGH_DATA) {
                
                // 1. Dibujar la imagen base en el canvas
                ctx.drawImage(videoBg, 0, 0, canvas.width, canvas.height);

                // 2. Aplicar el filtro seleccionado
                if (currentFilter === 'sls') {
                    // MODO IA: Analizar el canvas y dibujar esqueletos encima
                    if (poseDetector) {
                        const poses = await poseDetector.estimatePoses(canvas); 
                        drawAllSkeletons(poses); // Dibuja líneas y puntos sobre el video
                    }
                
                } else if (currentFilter === 'relief' || currentFilter === 'scanner-diag') {
                    // MODO PROCESAMIENTO: Tomar la imagen, procesar píxeles y reemplazarla
                    let frame = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    let data = frame.data;
                    let width = canvas.width;
                    let height = canvas.height;

                    if (currentFilter === 'relief') {
                        let copy = new Uint8ClampedArray(data);
                        for (let y = 1; y < height - 1; y++) {
                            for (let x = 1; x < width - 1; x++) {
                                let i = (y * width + x) * 4;
                                let h = -copy[((y-1)*width+(x-1))*4] + copy[((y-1)*width+(x+1))*4]
                                      -2*copy[(y*width+(x-1))*4] + 2*copy[(y*width+(x+1))*4]
                                      -copy[((y+1)*width+(x-1))*4] + copy[((y+1)*width+(x+1))*4];
                                let v = -copy[((y-1)*width+(x-1))*4] - 2*copy[((y-1)*width+x)*4] - copy[((y-1)*width+(x+1))*4]
                                      +copy[((y+1)*width+(x-1))*4] + 2*copy[((y+1)*width+x)*4] + copy[((y+1)*width+(x+1))*4];
                                let diff = Math.sqrt(h*h + v*v);
                                
                                if (diff > 40) {
                                    data[i] = diff; data[i+1] = 255; data[i+2] = 255; 
                                } else {
                                    data[i] = 10; data[i+1] = 10; data[i+2] = 10; 
                                }
                            }
                        }
                    } 
                    else if (currentFilter === 'scanner-diag') {
                        edgeMap = new Uint8ClampedArray(data.length); 
                        let copy = new Uint8ClampedArray(data);
                        for (let y = 1; y < height - 1; y++) {
                            for (let x = 1; x < width - 1; x++) {
                                let i = (y * width + x) * 4;
                                let h = -copy[((y-1)*width+(x-1))*4] + copy[((y-1)*width+(x+1))*4]
                                      -2*copy[(y*width+(x-1))*4] + 2*copy[(y*width+(x+1))*4]
                                      -copy[((y+1)*width+(x-1))*4] + copy[((y+1)*width+(x+1))*4];
                                let v = -copy[((y-1)*width+(x-1))*4] - 2*copy[((y-1)*width+x)*4] - copy[((y-1)*width+(x+1))*4]
                                      +copy[((y+1)*width+(x-1))*4] + 2*copy[((y+1)*width+x)*4] + copy[((y+1)*width+(x+1))*4];
                                
                                if (Math.sqrt(h*h + v*v) > 35) { 
                                    edgeMap[i+3] = 255; 
                                }
                            }
                        }

                        sweepDiagonal = (sweepDiagonal + 3) % (width + height); 
                        
                        for(let lineOffset = 0; lineOffset < 30; lineOffset += 5) { 
                            let linePos = sweepDiagonal - lineOffset;
                            
                            for (let y = 0; y < height; y++) {
                                let x = linePos - y;
                                if (x >= 0 && x < width) {
                                    let i = (y * width + x) * 4;
                                    if (edgeMap[i+3] > 0) {
                                        data[i] = 0; data[i+1] = 255; data[i+2] = 255; data[i+3] = 255; 
                                    }
                                }
                            }
                        }
                    }
                    
                    // 3. Reemplazar el canvas con la data procesada
                    ctx.putImageData(frame, 0, 0);
                }
            }
            // 4. Pedir el siguiente frame
            requestAnimationFrame(drawLoop);
        }
        
        // --- SOLUCIÓN 1: NUEVAS FUNCIONES PARA DIBUJAR ESQUELETOS DE IA ---
        
        const confidenceThreshold = 0.3; // Confianza mínima de la IA (0.0 a 1.0)
        // Mapa de conexiones de MoveNet
        const skeletonMap = [
            ['left_shoulder', 'right_shoulder'], ['left_shoulder', 'left_elbow'],
            ['left_elbow', 'left_wrist'], ['right_shoulder', 'right_elbow'],
            ['right_elbow', 'right_wrist'], ['left_shoulder', 'left_hip'],
            ['right_shoulder', 'right_hip'], ['left_hip', 'right_hip'],
            ['left_hip', 'left_knee'], ['left_knee', 'left_ankle'],
            ['right_hip', 'right_knee'], ['right_knee', 'right_ankle']
        ];
        
        /** Dibuja todos los esqueletos detectados en la lista de 'poses' */
        function drawAllSkeletons(poses) {
            ctx.strokeStyle = 'var(--neon-green)';
            ctx.fillStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.globalAlpha = 0.8; // Un poco de transparencia

            poses.forEach(pose => {
                if (pose.score > confidenceThreshold) {
                    drawKeypoints(pose.keypoints);
                    drawConnections(pose.keypoints);
                }
            });
            ctx.globalAlpha = 1.0; // Restaurar alfa
        }

        /** Dibuja los puntos (articulaciones) */
        function drawKeypoints(keypoints) {
            for (let i = 0; i < keypoints.length; i++) {
                const keypoint = keypoints[i];
                if (keypoint.score > confidenceThreshold) {
                    ctx.beginPath();
                    ctx.arc(keypoint.x, keypoint.y, 4, 0, 2 * Math.PI); // Círculo de 4px
                    ctx.fill();
                }
            }
        }

        /** Dibuja las líneas (huesos) que conectan las articulaciones */
        function drawConnections(keypoints) {
            const keypointMap = new Map();
            keypoints.forEach(keypoint => {
                keypointMap.set(keypoint.name, keypoint);
            });

            skeletonMap.forEach(connection => {
                const start = keypointMap.get(connection[0]);
                const end = keypointMap.get(connection[1]);

                if (start && end && start.score > confidenceThreshold && end.score > confidenceThreshold) {
                    ctx.beginPath();
                    ctx.moveTo(start.x, start.y);
                    ctx.lineTo(end.x, end.y);
                    ctx.stroke();
                }
            });
        }
        // --- FIN DE LAS NUEVAS FUNCIONES DE IA ---

        function setFilter(f) {
            currentFilter = f;
            document.querySelectorAll('.cam-btn').forEach(b => b.classList.remove('active'));
            event.target.classList.add('active');
            edgeMap = null; 
        }

        // AUDIO
        function initAudio() {
            if (audioCtx) return;
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            masterGain = audioCtx.createGain();
            masterGain.connect(audioCtx.destination);

            whiteNoiseNode = audioCtx.createBufferSource();
            let b = audioCtx.createBuffer(1, audioCtx.sampleRate*2, audioCtx.sampleRate);
            let d = b.getChannelData(0);
            for(let i=0;i<d.length;i++) d[i] = Math.random()*2-1;
            whiteNoiseNode.buffer = b; whiteNoiseNode.loop = true;
            
            gainNode = audioCtx.createGain(); gainNode.gain.value = 0;
            
            lfo = audioCtx.createOscillator(); lfo.type = 'square'; lfo.frequency.value = 8;
            lfoGain = audioCtx.createGain(); lfoGain.gain.value = 0.05;
            lfo.connect(lfoGain).connect(gainNode.gain);
            
            whiteNoiseNode.connect(gainNode); gainNode.connect(masterGain);

            radioOsc = audioCtx.createOscillator();
            radioOsc.type = 'sine';
            radioOsc.frequency.value = 1000;
            radioGain = audioCtx.createGain();
            radioGain.gain.value = 0; 
            radioOsc.connect(radioGain).connect(masterGain);
            
            reverbGain = audioCtx.createGain();
            reverbGain.gain.value = 0.8; 
            let delay = audioCtx.createDelay(); delay.delayTime.value = 0.5; 
            let fb = audioCtx.createGain(); fb.gain.value = 0.7;
            gainNode.connect(delay); delay.connect(fb); fb.connect(delay);
            delay.connect(reverbGain).connect(masterGain);
            
            distortionNode = audioCtx.createWaveShaper();
            distortionNode.curve = makeDistortionCurve(50);
            gainNode.connect(distortionNode);
            distortionNode.connect(masterGain);

            setInterval(() => {
                if(isRunning) {
                    let freq = 800 + Math.random() * 1500; 
                    radioOsc.frequency.setValueAtTime(freq, audioCtx.currentTime); 
                }
            }, 300);

            radioOsc.start(); whiteNoiseNode.start(); lfo.start();
            initSpeechRec();
        }
        
        function makeDistortionCurve(amount) {
            let k = typeof amount === 'number' ? amount : 50,
                n_samples = 44100,
                curve = new Float32Array(n_samples),
                deg = Math.PI / 180,
                i = 0, x;
            for ( ; i < n_samples; ++i ) {
                x = i * 2 / n_samples - 1;
                curve[i] = ( 3 + k ) * x * 20 * deg / ( Math.PI + k * Math.abs(x) );
            }
            return curve;
        }

        // SENSOR EMF
        function initSensor() {
            if (emfSimInterval) clearInterval(emfSimInterval); 
            
            if ('Magnetometer' in window) {
                try {
                    magnetometer = new Magnetometer({ frequency: 5 }); 
                    magnetometer.onreading = () => {
                        let strength = Math.sqrt(magnetometer.x**2 + magnetometer.y**2 + magnetometer.z**2);
                        emfValue = Math.min(100, (strength - 40) * 0.5); 
                        if (emfValue < 0) emfValue = 0;
                        if(sensorLed) sensorLed.classList.add('active-sensor'); 
                    };
                    magnetometer.onerror = (e) => {
                        console.warn("Error de Magnetómetro:", e.error.name, "Iniciando simulador.");
                        if(sensorLed) sensorLed.classList.remove('active-sensor'); 
                        startEmfSimulation(); 
                    };
                    magnetometer.start();
                    console.log("Sensor EMF (Magnetómetro) activado.");
                } catch(e) {
                    console.warn("No se pudo iniciar Magnetómetro. Iniciando simulador.");
                    if(sensorLed) sensorLed.classList.remove('active-sensor');
                    startEmfSimulation(); 
                }
            } else {
                console.warn("Magnetómetro no soportado. Iniciando simulador.");
                if(sensorLed) sensorLed.classList.remove('active-sensor');
                startEmfSimulation(); 
            }
        }
        
        function startEmfSimulation() {
            if (emfSimInterval) return;
            emfSimInterval = setInterval(() => {
                emfValue = Math.random() * 100;
            }, 200);
        }
        
        function stopSensor() {
            if (magnetometer) magnetometer.stop();
            if (emfSimInterval) clearInterval(emfSimInterval);
            emfSimInterval = null;
            emfValue = 0;
            if(sensorLed) sensorLed.classList.remove('active-sensor');
        }

        
        function startVisualLoop() {
            if (visualLoopInterval) clearInterval(visualLoopInterval); 
            visualLoopInterval = setInterval(() => {
                let intensity = emfValue; 
                
                let ledIntensity = Math.floor(intensity / 10); 
                updateLEDs(ledIntensity);
                updateEnergyGraph(intensity); 

                if(isRunning) {
                    document.getElementById('main-needle').style.transform = `translateX(-50%) rotate(${-45 + (intensity/100)*90}deg)`;
                    vuL.style.width = (intensity*0.6)+'%'; 
                    vuR.style.width = (intensity*0.6)+'%';
                }
            }, 150); 
        }
        
        function stopVisualLoop() {
            if (!isRunning) {
                document.getElementById('main-needle').style.transform = `translateX(-50%) rotate(-45deg)`;
                vuL.style.width = '0%'; 
                vuR.style.width = '0%';
            }
        }

        const pwr = document.getElementById('knob-power');
        pwr.addEventListener('click', () => {
            if(!audioCtx) initAudio();
            isRunning = !isRunning;
            
            if(isRunning) {
                pwr.style.transform = 'rotate(0deg)';
                pwr.style.boxShadow = '0 0 15px var(--glow-color)';
                detectorPanel.classList.add('retro-lit'); 
                envContent.classList.add('active'); 
                
                if(audioCtx.state === 'suspended') audioCtx.resume();
                lfoGain.gain.linearRampToValueAtTime(0.05, audioCtx.currentTime+0.5);
                radioGain.gain.linearRampToValueAtTime(0.02, audioCtx.currentTime+0.5); 
                
                startAutoMode();
                
            } else {
                pwr.style.transform = 'rotate(-135deg)';
                pwr.style.boxShadow = 'none';
                detectorPanel.classList.remove('retro-lit');
                envContent.classList.remove('active');
                
                lfoGain.gain.linearRampToValueAtTime(0, audioCtx.currentTime+0.1);
                radioGain.gain.linearRampToValueAtTime(0, audioCtx.currentTime+0.1); 
                
                isRecognizing = false;
                window.speechSynthesis.cancel();
            }
            if (isRunning) {
            } else {
                stopVisualLoop(); 
            }
        });

        document.getElementById('knob-scan').addEventListener('click', function() {
            scanSpeed = (scanSpeed+1)%3;
            this.style.transform = `rotate(${-135 + scanSpeed*135}deg)`;
            if(lfo) lfo.frequency.linearRampToValueAtTime([5,12,20][scanSpeed], audioCtx.currentTime+0.1);
        });

        document.getElementById('vol-slider').addEventListener('input', (e) => {
            if(masterGain) masterGain.gain.value = e.target.value/100;
        });

        async function loadSheetData() {
            try {
                let [ra, rp] = await Promise.all([
                    fetch(`${SHEETDB_URL}?sheet=AUTOMATICO`), 
                    fetch(`${SHEETDB_URL}?sheet=PROGRAMADO`)
                ]);
                let ja = await ra.json(); automaticoData = ja.map(r=>r.TEXTO||r.texto).filter(t=>t);
                let jp = await rp.json();
                jp.forEach(r=>{
                    let p=(r.PREGUNTA||r.pregunta||"").toLowerCase().normalize("NFD").replace(/[\u0300-\u036f]/g,"");
                    let res=r.RESPUESTA||r.respuesta;
                    if(p&&res) programadoData.set(p,res);
                });
                console.log("Datos cargados:", automaticoData.length, programadoData.size);
            } catch(e){ console.error("Error datos", e); }
        }
        loadSheetData();

        function speak(text) {
            isSpeaking = true;
            
            // Efecto de "barrido sucio" sobre la voz (V5.17)
            lfoGain.gain.linearRampToValueAtTime(0.08, audioCtx.currentTime+0.1);
            lfo.frequency.linearRampToValueAtTime(15, audioCtx.currentTime + 0.1);
            radioGain.gain.linearRampToValueAtTime(0.01, audioCtx.currentTime+0.1);
            
            const u = new SpeechSynthesisUtterance(text);
            u.lang = 'es-MX'; 
            u.volume = 1.0; 
            u.pitch = 1.0; 
            u.rate = 1.1; 
            
            u.onend = () => {
                isSpeaking = false;
                // Devolver el LFO a la normalidad
                lfoGain.gain.linearRampToValueAtTime(0.05, audioCtx.currentTime+0.2);
                lfo.frequency.linearRampToValueAtTime([5,12,20][scanSpeed], audioCtx.currentTime + 0.2);
                radioGain.gain.linearRampToValueAtTime(0.02, audioCtx.currentTime+0.2);
            };
            window.speechSynthesis.speak(u);
            
            sensorPanel.classList.add('alert');
            emfValue = 80 + Math.random() * 20; 
            setTimeout(() => sensorPanel.classList.remove('alert'), 500);
        }

        function startAutoMode() {
            if(!isRunning) return;
            setTimeout(() => {
                if(isRunning && !isSpeaking && automaticoData.length>0 && Math.random()>0.5) {
                    speak(automaticoData[Math.floor(Math.random()*automaticoData.length)]);
                }
                startAutoMode();
            }, 3000+Math.random()*4000);
        }

        function initSpeechRec() {
            if(!SpeechRecognition) return;
            recognition = new SpeechRecognition(); 
            recognition.lang = 'es-MX'; 
            recognition.continuous = false;
            recognition.onstart = () => { 
                isRecognizing = true;
                if(micLed) micLed.classList.add('active-mic'); 
            };
            
            recognition.onend = () => { 
                isRecognizing = false;
                if(micLed) micLed.classList.remove('active-mic'); 
            };
            
            recognition.onerror = () => {
                isRecognizing = false;
                if(micLed) micLed.classList.remove('active-mic');
            };
            recognition.onresult = (e) => {
                let t = e.results[0][0].transcript.toLowerCase().normalize("NFD").replace(/[\u0300-\u036f]/g,"");
                if(programadoData.has(t)) speak(programadoData.get(t));
            };
        }
        
        function persistentMicCheck(){ 
            if(isRunning && !isRecognizing && !isSpeaking) {
                try { 
                    recognition.start(); 
                } catch(e) { 
                    isRecognizing = false; 
                    if(micLed) micLed.classList.remove('active-mic');
                } 
            }
        }

        function updateLEDs(intensity) { 
            segments.forEach((seg, i) => { 
                seg.className = 'led-segment';
                if (i < intensity) {
                    if (i < 3) seg.classList.add('active-blue');
                    else if (i < 7) seg.classList.add('active-yellow');
                    else seg.classList.add('active-red');
                }
            });
        }

        function updateEnergyGraph(value) {
            if (!energyCtx || !energyCanvas) return; 
            
            energyHistory.push(value);
            if (energyHistory.length > 50) energyHistory.shift();

            let w = energyCanvas.width;
            let h = energyCanvas.height;
            if (w === 0 || h === 0) {
                resizeEnergyCanvas();
                w = energyCanvas.width;
                h = energyCanvas.height;
                if(w === 0 || h === 0) return;
            }
            
            energyCtx.clearRect(0, 0, w, h);
            let step = w / energyHistory.length;

            energyCtx.beginPath();
            energyCtx.strokeStyle = 'var(--glow-color)';
            energyCtx.lineWidth = 1;
            energyCtx.moveTo(0, h - (energyHistory[0] / 100 * h));
            for(let i=1; i<energyHistory.length; i++) {
                energyCtx.lineTo(i * step, h - (energyHistory[i] / 100 * h));
            }
            energyCtx.stroke();
            
            energyCtx.beginPath();
            energyCtx.strokeStyle = 'var(--alert-red)';
            energyCtx.lineWidth = 2; 
            let inPeak = false;
            for(let i=0; i<energyHistory.length; i++) {
                let val = energyHistory[i];
                let y = h - (val / 100 * h);
                
                if (val > 70) { 
                    if (!inPeak) {
                        energyCtx.moveTo(i * step, y);
                        inPeak = true;
                    } else {
                        energyCtx.lineTo(i * step, y);
                    }
                } else {
                    inPeak = false;
                }
            }
            energyCtx.stroke(); 
        }

        function resizeEnergyCanvas() {
            if(energyCanvas && energyCanvas.parentElement) {
                energyCanvas.width = energyCanvas.parentElement.offsetWidth;
                energyCanvas.height = energyCanvas.parentElement.offsetHeight;
            }
        }


        function updateSensorReadings() {
            currentTemp += (Math.random()*0.04 - 0.02); 
            document.getElementById('temp-val').innerText = currentTemp.toFixed(1)+"°C";
        }
        setInterval(updateSensorReadings, 2000);

        // UI
        const menu = document.getElementById('menu-tools');
        let mT;
        document.getElementById('btn-ver').addEventListener('click', () => {
            menu.classList.toggle('visible');
            clearTimeout(mT);
            if(menu.classList.contains('visible')) mT = setTimeout(()=>menu.classList.remove('visible'), 5000);
        });
        
        
        function checkPanelState() {
            const anyVis = !document.getElementById('p-camera').classList.contains('hidden') || 
                           !document.getElementById('p-detector').classList.contains('hidden') ||
                           !document.getElementById('p-env').classList.contains('hidden');
            if(anyVis) document.body.classList.add('panels-active');
            else document.body.classList.remove('panels-active');
        }

        function togglePanel(id) {
            const p = document.getElementById(id);
            const btn = document.querySelector(`.menu-item[onclick="togglePanel('${id}')"]`);
            p.classList.toggle('hidden');
            if(btn) btn.classList.toggle('active');
            
            checkPanelState(); 
            
            menu.classList.remove('visible');
            
            if(id === 'p-env' && !p.classList.contains('hidden')) resizeEnergyCanvas();
        }

        window.onload = () => {
            startCamera();
            initSensor(); 
            startVisualLoop(); 
            initMLModel(); // SOLUCIÓN 1: Cargar el modelo de IA al iniciar
            
            setInterval(updateSensorReadings, 2000); 
            setInterval(persistentMicCheck, 1000); 
            checkPanelState(); 
        };
        
        window.onresize = () => {
            if(energyCanvas && !document.getElementById('p-env').classList.contains('hidden')) {
                resizeEnergyCanvas();
            }
        };
    </script>
</body>
</html>
