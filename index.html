<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>OBR-FIELD-UNIT V5.22</title> <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=Orbitron:wght@500;700&display=swap" rel="stylesheet">
    
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-core"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-converter"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgl"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection"></script>

    <style>
        :root {
            --glow-color: #00FFFF; 
            --panel-bg: #1a1a1a; 
            --neon-green: #39FF14; 
            --alert-red: #FF3333;
            --amber-light: rgba(255, 176, 0, 0.1);
            --led-blue: #0055FF;
            --led-yellow: #FFCC00;
            
            --panel-width: 280px; 
        }
        
        body {
            font-family: 'Share Tech Mono', monospace;
            background-color: #000;
            color: var(--glow-color);
            overflow: hidden;
            width: 100vw;
            height: 100vh;
        }

        #app-ui {
            width: 100%;
            height: 100%;
            position: relative;
        }

        #main-view-area {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            transition: all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }

        #bg-camera-feed {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover; 
            z-index: 1;
            filter: brightness(1.0);
            transform: scaleX(1); 
        }
        
        #main-filter-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2; 
            pointer-events: none; 
        }
        
        .hidden-canvas { display: none; }

        #side-panel-container {
            position: fixed;
            top: 0;
            left: 0;
            width: var(--panel-width);
            height: 100vh;
            display: flex;
            flex-direction: column;
            z-index: 20;
            pointer-events: none; 
            transform: translateX(calc(var(--panel-width) * -1));
            transition: transform 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }

        body.panels-active #side-panel-container {
            transform: translateX(0);
        }
        body.panels-active #main-view-area {
            left: var(--panel-width);
            width: calc(100% - var(--panel-width));
        }


        .panel {
            background: repeating-linear-gradient(135deg, #1a1a1a, #1a1a1a 10px, #222 10px, #222 12px);
            border: 1px solid #444;
            border-top: 1px solid #666;
            border-bottom: 1px solid #000;
            border-radius: 8px;
            box-shadow: inset 0 0 20px #000, 0 5px 15px rgba(0,0,0,0.8);
            display: flex;
            flex-direction: column;
            padding: 8px;
            position: relative;
            overflow: hidden;
            transition: box-shadow 0.3s ease;
            pointer-events: auto;
            margin: 5px; 
        }
        
        #p-env {
            flex-basis: 40%; 
            max-height: 40vh;
        }
        
        #p-detector {
            flex-grow: 1; 
            max-height: 58vh;
        }

        .panel.alert {
            box-shadow: inset 0 0 20px #000, 0 5px 15px rgba(0,0,0,0.8), 0 0 20px var(--alert-red);
            border-color: var(--alert-red);
        }
        
        .panel::before, .panel::after {
            content: ''; position: absolute; top: 5px; width: 6px; height: 6px;
            background: radial-gradient(circle, #555, #111);
            border-radius: 50%; box-shadow: 0 1px 0 rgba(255,255,255,0.2);
        }
        .panel::before { left: 5px; }
        .panel::after { right: 5px; }

        #p-detector.retro-lit::before {
            content: ''; position: absolute; top:0; left:0; width:100%; height:100%;
            background: radial-gradient(circle at center, var(--amber-light), transparent 80%);
            pointer-events: none; z-index: 0; animation: flicker 0.1s infinite;
        }
        @keyframes flicker { 0% { opacity: 0.95; } 100% { opacity: 1; } }
        
        .panel.hidden { display: none; }

        .panel-header {
            font-size: 0.6rem; text-align: center; margin-bottom: 5px; color: #888;
            text-shadow: 0 -1px 0 #000; border-bottom: 2px groove #333; padding-bottom: 2px;
            text-transform: uppercase; letter-spacing: 1px; background: rgba(0,0,0,0.3);
            border-radius: 4px; z-index: 1;
        }

        .header-title {
            position: fixed;
            top: 0; 
            left: 50%;
            transform: translateX(-50%);
            width: auto;
            text-align: center;
            font-family: 'Orbitron', sans-serif;
            font-size: 0.9rem;
            font-weight: 700;
            color: rgba(0, 255, 255, 0.8);
            text-shadow: 0 0 5px var(--glow-color);
            letter-spacing: 3px;
            background: linear-gradient(to bottom, rgba(0,0,0,0.9), transparent);
            padding: 15px 30px;
            pointer-events: auto;
            animation: breatheSlow 20s infinite ease-in-out; 
            z-index: 100; 
            opacity: 0; 
        }
        
        @keyframes breatheSlow {
            0%, 80% { opacity: 0; } 
            90% { opacity: 0.7; text-shadow: 0 0 10px var(--glow-color); }
            100% { opacity: 0; }
        }

        /* --- Estilos Paneles --- */
        .emf-container, .env-content {
            display: flex; flex-direction: column; height: 100%; justify-content: space-between; z-index: 1;
        }
        .vu-section { display: flex; justify-content: space-between; margin-bottom: 5px; gap: 5px; height: 15px; }
        .vu-box { flex: 1; background: #111; border: 1px inset #444; position: relative; overflow: hidden; }
        .vu-bar-fill { height: 100%; width: 0%; opacity: 0.9; transition: width 0.05s linear; }
        #vu-l { background: linear-gradient(to right, #00ff00, #ffff00, #ff0000); float: left; }
        #vu-r { background: linear-gradient(to left, #00ff00, #ffff00, #ff0000); float: right; }
        .meter-section { flex-grow: 1; position: relative; background: radial-gradient(circle at 50% 100%, #222, #000); border: 1px solid #333; border-radius: 4px; margin-bottom: 5px; box-shadow: inset 0 0 10px #000; }
        .meter-freqs { position: absolute; top: 5px; left: 0; width: 100%; text-align: center; font-size: 0.45rem; color: #555; z-index: 1; display: flex; justify-content: space-between; padding: 0 10px; }
        #main-needle { width: 2px; height: 85%; background: #ff5500; position: absolute; bottom: 0; left: 50%; transform-origin: bottom center; transform: rotate(-45deg); transition: transform 0.1s cubic-bezier(0.2, 1.5, 0.5, 1); box-shadow: 0 0 5px #ff5500; z-index: 2; }
        .knobs-section { display: flex; justify-content: space-around; margin-bottom: 5px; }
        .knob-circle { width: 45px; height: 45px; border-radius: 50%; border: 2px solid #555; position: relative; margin: 0 auto 2px auto; cursor: pointer; background: conic-gradient(#222, #000, #222); box-shadow: 0 3px 5px #000; }
        .knob-circle::after { content:''; position:absolute; top:0; left:0; width:100%; height:100%; border-radius:50%; background: linear-gradient(135deg, rgba(255,255,255,0.1), transparent); }
        .knob-indicator { position: absolute; top: 4px; left: 50%; width: 2px; height: 15px; background: #ff5500; transform: translateX(-50%); }
        .knob-label { font-size: 0.6rem; color: #aaa; text-align: center; text-shadow: 0 1px 0 #000; }
        .volume-slider-container { width: 100%; display: flex; align-items: center; gap: 8px; padding: 5px 0; }
        input[type=range] { flex-grow: 1; -webkit-appearance: none; height: 25px; background: #111; border: 1px solid #333; border-radius: 10px; overflow: hidden; }
        input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; width: 35px; height: 35px; background: #444; border: 1px solid #666; border-radius: 50%; box-shadow: -100vw 0 0 100vw var(--glow-color); cursor: pointer; }
        
        .temp-readout { font-size: 2.5rem; font-weight: bold; color: var(--glow-color); text-shadow: 0 0 15px rgba(0,255,255,0.3); background: rgba(0,0,0,0.5); padding: 10px 15px; border: 2px solid #333; border-left: 4px solid var(--glow-color); border-radius: 0 10px 10px 0; font-family: 'Share Tech Mono', monospace; transition: all 0.5s ease; text-align: center; }
        .temp-label-small { font-size: 0.6rem; color: #666; margin-top: 5px; text-align: center; }
        .energy-container { width: 100%; display: flex; flex-direction: column; align-items: center; height: auto; opacity: 1; flex-grow: 1; margin-top: 5px; transform: scaleY(1); }
        .env-content.active .temp-readout { font-size: 1.5rem; padding: 5px 15px; border-width: 1px; }
        .led-bar { display: flex; gap: 3px; margin-bottom: 5px; background: #000; padding: 4px; border-radius: 4px; border: 1px solid #333; }
        .led-segment { width: 8px; height: 15px; background-color: #111; border: 1px solid #222; transition: background-color 0.1s; }
        .led-segment.active-blue { background-color: var(--led-blue); box-shadow: 0 0 10px var(--led-blue); }
        .led-segment.active-yellow { background-color: var(--led-yellow); box-shadow: 0 0 10px var(--led-yellow); }
        .led-segment.active-red { background-color: var(--alert-red); box-shadow: 0 0 15px var(--alert-red); }
        .energy-label { font-size: 0.6rem; color: #aaa; margin-bottom: 5px; letter-spacing: 1px; }
        .energy-graph-box { width: 100%; height: 100%; flex-grow: 1; background: #000; border: 1px inset #333; border-radius: 5px; overflow: hidden; margin-top: 5px; min-height: 50px; }
        #energy-canvas { width: 100%; height: 100%; }
        .plate-obr { background: linear-gradient(to right, #222, #444, #222); border: 1px solid #000; color: #aaa; font-size: 0.6rem; padding: 4px 10px; box-shadow: 0 1px 0 rgba(255,255,255,0.1); text-shadow: 0 -1px 0 #000; border-radius: 2px; font-weight: bold; margin-top: 5px; }

        .status-led {
            width: 10px; height: 10px; 
            background-color: #333;
            border: 1px solid #000;
            border-radius: 50%;
            position: absolute;
            top: 10px; right: 10px;
            transition: all 0.2s;
            box-shadow: inset 0 0 3px #000;
        }
        #mic-led-container {
            position: absolute;
            top: 10px; left: 10px;
        }
        
        .status-led.active-mic {
            background-color: var(--alert-red);
            box-shadow: 0 0 8px var(--alert-red), 0 0 15px var(--alert-red);
            animation: pulse 1s infinite;
        }
        .status-led.active-sensor {
            background-color: var(--neon-green);
            box-shadow: 0 0 8px var(--neon-green), 0 0 15px var(--neon-green);
        }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }

        #menu-container {
            position: fixed;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 101;
            pointer-events: auto;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #btn-ver {
            width: 55px; height: 55px;
            border-radius: 50%; border: 2px solid #00aaaa;
            background: radial-gradient(#004444, #002222); color: #00ffff;
            font-weight: bold; font-size: 0.8rem; display: flex; justify-content: center;
            align-items: center; cursor: pointer; box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
        }
        #menu-tools {
            background: rgba(10,15,20,0.95);
            border: 1px solid #00aaaa; border-radius: 8px; padding: 5px;
            display: none;
            position: absolute;
            bottom: 65px; 
        }
        #menu-tools.visible { display: block; }
        .menu-item {
            padding: 10px 20px; color: #aaa; border-bottom: 1px solid #333;
            cursor: pointer; font-size: 0.7rem;
        }
        .menu-item.active { 
            color: #00ffff; 
            text-shadow: 0 0 5px #00ffff; 
            background: rgba(0, 255, 255, 0.1);
        }

        #filter-controls-container {
            position: fixed;
            top: 50%;
            right: 15px;
            transform: translateY(-50%);
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 100;
            pointer-events: auto;
        }
        .filter-btn {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: rgba(0, 50, 50, 0.7);
            border: 2px solid var(--glow-color);
            color: var(--glow-color);
            font-family: 'Share Tech Mono', monospace;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
            transition: all 0.2s;
        }
        .filter-btn:active {
            background: var(--glow-color);
            color: #000;
        }
        .filter-btn.active {
            background: var(--glow-color);
            color: #000;
            box-shadow: 0 0 20px #fff;
        }


        @media (max-width: 768px) and (orientation: portrait) {
            #side-panel-container {
                flex-direction: row; 
                bottom: 0;
                top: auto;
                left: 0;
                width: 100vw;
                height: auto;
                max-height: 50vh;
                transform: translateY(100%); 
                overflow-x: auto;
            }
            .panel {
                width: 280px; 
                flex-shrink: 0;
                height: 280px;
            }
            #p-env { max-height: 100%; flex-basis: auto; }
            #p-detector { max-height: 100%; flex-basis: auto; }

            body.panels-active #side-panel-container {
                transform: translateY(0);
            }
            body.panels-active #main-view-area {
                left: 0;
                width: 100%;
                filter: brightness(0.4);
            }
            
            #filter-controls-container { right: 10px; }
            .filter-btn { width: 45px; height: 45px; }
            
            #menu-container { left: 50%; transform: translateX(-50%); }
            
            @media (max-width: 768px) and (orientation: landscape) {
                :root { --panel-width: 240px; }
            }
        }
    </style>
</head>
<body>

<div id="app-ui">

    <div id="main-view-area">
        <video id="bg-camera-feed" playsinline autoplay muted></video>
        <canvas id="main-filter-canvas"></canvas>
    </div>
    <canvas id="temp-canvas" class="hidden-canvas"></canvas>

    <div class="header-title">EQUIPO PROFESIONAL DE EXPLORACIONES OBR</div>

    <div id="side-panel-container">
        
        <div class="panel" id="p-env">
            <div class="panel-header">SENSORES</div>
            
            <div id="mic-led-container">
                 <div class="status-led" id="mic-led" title="Micrófono Escuchando"></div>
            </div>
            <div class="status-led" id="sensor-led" title="Sensor EMF Real Activo"></div>
            
            <div class="env-content">
                <div class="temp-readout" id="temp-val">19.8°C</div>
                <div class="temp-label-small">TEMP AMBIENTE</div>
                
                <div class="energy-container">
                    <div class="energy-label" style="margin-top:10px;">INTENSIDAD DE CAMPO</div>
                    <div class="led-bar">
                        <div class="led-segment" id="seg-1"></div>
                        <div class="led-segment" id="seg-2"></div>
                        <div class="led-segment" id="seg-3"></div>
                        <div class="led-segment" id="seg-4"></div>
                        <div class="led-segment" id="seg-5"></div>
                        <div class="led-segment" id="seg-6"></div>
                        <div class="led-segment" id="seg-7"></div>
                        <div class="led-segment" id="seg-8"></div>
                        <div class="led-segment" id="seg-9"></div>
                        <div class="led-segment" id="seg-10"></div>
                    </div>
                    <div class="energy-graph-box">
                        <canvas id="energy-canvas"></canvas>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="panel" id="p-detector">
            <div class="panel-header">RADIO-FRECUENCIA</div>
            
            <div class="emf-container">
                <div class="vu-section">
                    <div class="vu-box"><div id="vu-l" class="vu-bar-fill"></div></div>
                    <div class="vu-box"><div id="vu-r" class="vu-bar-fill"></div></div>
                </div>
                <div class="meter-section">
                    <div class="meter-freqs">
                        <span>| 50</span><span>| 100</span><span>| 500</span><span>| 1k</span><span>| 10k |</span>
                    </div>
                    <div id="main-needle"></div>
                </div>
                <div class="knobs-section">
                    <div style="text-align:center">
                        <div class="knob-circle" id="knob-power" style="transform: rotate(-135deg);"><div class="knob-indicator"></div></div>
                        <div class="knob-label">POWER</div>
                    </div>
                    <div style="text-align:center">
                        <div class="knob-circle" id="knob-scan" style="transform: rotate(-135deg);"><div class="knob-indicator"></div></div>
                        <div class="knob-label">SCAN</div>
                    </div>
                </div>
                <div class="volume-slider-container">
                    <div class="knob-label">VOL</div>
                    <input type="range" min="0" max="100" value="80" id="vol-slider">
                </div>
            </div>
        </div>

    </div>

    <div id="filter-controls-container">
        <button class="filter-btn" onclick="setFilter('scanner-diag')">SCN</button>
        <button class="filter-btn" onclick="setFilter('sls')">SLS</button>
        <button class="filter-btn" onclick="setFilter('relief')">RLV</button>
    </div>

    <div id="menu-container">
        <div id="menu-tools">
            <div class="menu-item active" id="m-detector" onclick="togglePanel('p-detector')">SPIRIT BOX</div>
            <div class="menu-item active" id="m-env" onclick="togglePanel('p-env')">SENSORES</div>
        </div>
        <div id="btn-ver">VER</div>
    </div>

</div> 

    <script>
        const SHEETDB_URL = "https.sheetdb.io/api/v1/9xzfnke69kkej"; 
        let isRunning = false;
        let currentFilter = 'none'; 
        let scanSpeed = 0; 
        
        const videoBg = document.getElementById('bg-camera-feed');
        
        const mainFilterCanvas = document.getElementById('main-filter-canvas');
        const mainFilterCtx = mainFilterCanvas.getContext('2d', { willReadFrequently: true });

        const tempCanvas = document.getElementById('temp-canvas');
        const tempCtx = tempCanvas.getContext('2d', { willReadFrequently: true });
        
        const envContent = document.getElementById('env-content-box');
        const detectorPanel = document.getElementById('p-detector');
        const sensorPanel = document.getElementById('p-env'); 
        const segments = [1,2,3,4,5,6,7,8,9,10].map(i => document.getElementById('seg-'+i));
        const vuL = document.getElementById('vu-l');
        const vuR = document.getElementById('vu-r');
        
        const micLed = document.getElementById('mic-led');
        const sensorLed = document.getElementById('sensor-led');
        
        let energyHistory = new Array(50).fill(0);
        let energyCanvas, energyCtx;
        
        let audioCtx, masterGain, gainNode, lfo, lfoGain, whiteNoiseNode, radioOsc, radioGain, reverb, reverbGain, distortionNode;
        let isSpeaking = false; 
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        let recognition, isRecognizing = false;
        let programadoData = new Map();
        let automaticoData = [];
        let currentTemp = 19.8;
        
        let magnetometer; 
        let emfValue = 0; // Valor 0-100
        let emfSimInterval = null;
        let visualLoopInterval; 

        let poseDetector; 

        async function startCamera() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: { ideal: "environment" }, width: { ideal: 1280 } },
                    audio: false
                });
                videoBg.srcObject = stream;
                videoBg.onloadedmetadata = () => {
                    resizeAllCanvas(); 

                    energyCanvas = document.getElementById('energy-canvas');
                    if (energyCanvas) { 
                        energyCtx = energyCanvas.getContext('2d');
                        resizeEnergyCanvas();
                    }
                    drawLoop(); 
                };
            } catch (e) { console.log("Error camara", e); }
        }
        
        function resizeAllCanvas() {
            const w = window.innerWidth;
            const h = window.innerHeight;
            mainFilterCanvas.width = w;
            mainFilterCanvas.height = h;
            tempCanvas.width = w;
            tempCanvas.height = h;
        }

        async function initMLModel() {
            try {
                const model = poseDetection.SupportedModels.MoveNet;
                poseDetector = await poseDetection.createDetector(model);
                console.log("MoveNet (IA de Poses) cargado.");
            } catch (e) {
                console.error("Error al cargar modelo de IA:", e);
            }
        }

        let edgeMap = null; 
        let sweepDiagonal = 0; 

        // SOLUCIÓN 1: Nueva función para dibujar con 'cover'
        function drawVideoWithCover(ctx, video) {
            const canvasW = ctx.canvas.width;
            const canvasH = ctx.canvas.height;
            const videoW = video.videoWidth;
            const videoH = video.videoHeight;
            
            if (!videoW || !videoH) return; // Salir si el video no está listo

            const canvasAspect = canvasW / canvasH;
            const videoAspect = videoW / videoH;

            let drawW, drawH, drawX, drawY;

            if (videoAspect > canvasAspect) {
                // Video más ancho que el canvas (pillarbox)
                drawH = canvasH;
                drawW = canvasH * videoAspect;
                drawX = (canvasW - drawW) / 2;
                drawY = 0;
            } else {
                // Video más alto que el canvas (letterbox)
                drawW = canvasW;
                drawH = canvasW / videoAspect;
                drawX = 0;
                drawY = (canvasH - drawH) / 2;
            }
            
            ctx.drawImage(video, drawX, drawY, drawW, drawH);
        }

        
        async function drawLoop() {
            if (videoBg.readyState === videoBg.HAVE_ENOUGH_DATA) {
                
                const w = mainFilterCanvas.width;
                const h = mainFilterCanvas.height;

                mainFilterCtx.clearRect(0, 0, w, h);
                
                if (currentFilter === 'sls') {
                    // 1. Dibujar video en canvas (CORREGIDO)
                    drawVideoWithCover(mainFilterCtx, videoBg);
                    
                    // 2. Analizar y dibujar esqueletos
                    if (poseDetector) {
                        const poses = await poseDetector.estimatePoses(mainFilterCanvas); 
                        drawAllSkeletons(poses); 
                    }
                
                } else if (currentFilter === 'relief') {
                    // 1. Dibujar video en canvas (CORREGIDO)
                    drawVideoWithCover(mainFilterCtx, videoBg);
                    
                    // 2. Procesar
                    let frame = mainFilterCtx.getImageData(0, 0, w, h);
                    let data = frame.data;

                    let copy = new Uint8ClampedArray(data);
                    for (let y = 1; y < h - 1; y++) {
                        for (let x = 1; x < w - 1; x++) {
                            let i = (y * w + x) * 4;
                            let hpx = -copy[((y-1)*w+(x-1))*4] + copy[((y-1)*w+(x+1))*4]
                                  -2*copy[(y*w+(x-1))*4] + 2*copy[(y*w+(x+1))*4]
                                  -copy[((y+1)*w+(x-1))*4] + copy[((y+1)*w+(x+1))*4];
                            let vpx = -copy[((y-1)*w+(x-1))*4] - 2*copy[((y-1)*w+x)*4] - copy[((y-1)*w+(x+1))*4]
                                  +copy[((y+1)*w+(x-1))*4] + 2*copy[((y+1)*w+x)*4] + copy[((y+1)*w+(x+1))*4];
                            let diff = Math.sqrt(hpx*hpx + vpx*vpx);
                            
                            if (diff > 40) {
                                data[i] = diff; data[i+1] = 255; data[i+2] = 255; 
                            } else {
                                data[i] = 10; data[i+1] = 10; data[i+2] = 10; 
                            }
                        }
                    }
                    mainFilterCtx.putImageData(frame, 0, 0);

                } else if (currentFilter === 'scanner-diag') {
                    // 1. Analizar en canvas temporal (CORREGIDO)
                    drawVideoWithCover(tempCtx, videoBg);
                    let frame = tempCtx.getImageData(0, 0, w, h);
                    let data = frame.data;
                    
                    edgeMap = new Uint8ClampedArray(data.length); 
                    let copy = new Uint8ClampedArray(data);
                    for (let y = 1; y < h - 1; y++) {
                        for (let x = 1; x < w - 1; x++) {
                            let i = (y * w + x) * 4;
                            let hpx = -copy[((y-1)*w+(x-1))*4] + copy[((y-1)*w+(x+1))*4]
                                  -2*copy[(y*w+(x-1))*4] + 2*copy[(y*w+(x+1))*4]
                                  -copy[((y+1)*w+(x-1))*4] + copy[((y+1)*w+(x+1))*4];
                            let vpx = -copy[((y-1)*w+(x-1))*4] - 2*copy[((y-1)*w+x)*4] - copy[((y-1)*w+(x+1))*4]
                                  +copy[((y+1)*w+(x-1))*4] + 2*copy[((y+1)*w+x)*4] + copy[((y+1)*w+(x+1))*4];
                            
                            if (Math.sqrt(hpx*hpx + vpx*vpx) > 35) { 
                                edgeMap[i+3] = 255; 
                            }
                        }
                    }

                    // 2. Dibujar líneas en canvas principal
                    sweepDiagonal = (sweepDiagonal + 5) % (w + h); 
                    
                    // SOLUCIÓN 4: Color cambiado a azul neón
                    mainFilterCtx.fillStyle = 'var(--glow-color)';
                    mainFilterCtx.shadowColor = 'var(--glow-color)';
                    mainFilterCtx.shadowBlur = 10;
                    
                    for(let lineOffset = 0; lineOffset < 30; lineOffset += 5) { 
                        let linePos = sweepDiagonal - lineOffset;
                        
                        for (let y = 0; y < h; y+=2) { 
                            let x = linePos - y;
                            if (x >= 0 && x < w) {
                                let i = (y * w + x) * 4;
                                if (edgeMap[i+3] > 0) {
                                    mainFilterCtx.fillRect(x, y, 2, 2);
                                }
                            }
                        }
                    }
                    mainFilterCtx.shadowBlur = 0;
                
                } else if (currentFilter === 'none') {
                    // El canvas se queda transparente
                }
            }
            requestAnimationFrame(drawLoop);
        }
        
        const confidenceThreshold = 0.3; 
        const skeletonMap = [
            ['left_shoulder', 'right_shoulder'], ['left_shoulder', 'left_elbow'],
            ['left_elbow', 'left_wrist'], ['right_shoulder', 'right_elbow'],
            ['right_elbow', 'right_wrist'], ['left_shoulder', 'left_hip'],
            ['right_shoulder', 'right_hip'], ['left_hip', 'right_hip'],
            ['left_hip', 'left_knee'], ['left_knee', 'left_ankle'],
            ['right_hip', 'right_knee'], ['right_knee', 'right_ankle']
        ];
        
        function drawAllSkeletons(poses) {
            // SOLUCIÓN 2: Líneas Verdes, Puntos Rojos (con Hex)
            mainFilterCtx.strokeStyle = '#39FF14'; // var(--neon-green)
            mainFilterCtx.fillStyle = '#FF3333';   // var(--alert-red)
            mainFilterCtx.lineWidth = 2.5;
            mainFilterCtx.filter = 'drop-shadow(0 0 4px #39FF14)';

            poses.forEach(pose => {
                if (pose.score > confidenceThreshold) {
                    drawKeypoints(pose.keypoints);
                    drawConnections(pose.keypoints);
                }
            });
            mainFilterCtx.filter = 'none';
        }

        function drawKeypoints(keypoints) {
            for (let i = 0; i < keypoints.length; i++) {
                const keypoint = keypoints[i];
                if (keypoint.score > confidenceThreshold) {
                    mainFilterCtx.beginPath();
                    mainFilterCtx.arc(keypoint.x, keypoint.y, 4, 0, 2 * Math.PI); 
                    mainFilterCtx.fill();
                }
            }
        }

        function drawConnections(keypoints) {
            const keypointMap = new Map();
            keypoints.forEach(keypoint => {
                keypointMap.set(keypoint.name, keypoint);
            });

            skeletonMap.forEach(connection => {
                const start = keypointMap.get(connection[0]);
                const end = keypointMap.get(connection[1]);

                if (start && end && start.score > confidenceThreshold && end.score > confidenceThreshold) {
                    mainFilterCtx.beginPath();
                    mainFilterCtx.moveTo(start.x, start.y);
                    mainFilterCtx.lineTo(end.x, end.y);
                    mainFilterCtx.stroke();
                }
            });
        }

        // SOLUCIÓN 3: Lógica de filtros actualizada (sin NRM)
        function setFilter(f) {
            document.querySelectorAll('.filter-btn').forEach(b => b.classList.remove('active'));
            
            if (currentFilter === f) {
                currentFilter = 'none'; // Desactivar
            } else {
                currentFilter = f; // Activar
                // Encontrar y activar el botón presionado
                const targetBtn = event ? event.target : document.querySelector(`.filter-btn[onclick="setFilter('${f}')"]`);
                if(targetBtn) targetBtn.classList.add('active');
            }
        }

        // --- Resto del código (Audio, Sensores, UI) sin cambios ---

        // AUDIO
        function initAudio() {
            if (audioCtx) return;
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            masterGain = audioCtx.createGain();
            masterGain.connect(audioCtx.destination);

            whiteNoiseNode = audioCtx.createBufferSource();
            let b = audioCtx.createBuffer(1, audioCtx.sampleRate*2, audioCtx.sampleRate);
            let d = b.getChannelData(0);
            for(let i=0;i<d.length;i++) d[i] = Math.random()*2-1;
            whiteNoiseNode.buffer = b; whiteNoiseNode.loop = true;
            
            gainNode = audioCtx.createGain(); gainNode.gain.value = 0;
            
            lfo = audioCtx.createOscillator(); lfo.type = 'square'; lfo.frequency.value = 8;
            lfoGain = audioCtx.createGain(); lfoGain.gain.value = 0.05;
            lfo.connect(lfoGain).connect(gainNode.gain);
            
            whiteNoiseNode.connect(gainNode); gainNode.connect(masterGain);

            radioOsc = audioCtx.createOscillator();
            radioOsc.type = 'sine';
            radioOsc.frequency.value = 1000;
            radioGain = audioCtx.createGain();
            radioGain.gain.value = 0; 
            radioOsc.connect(radioGain).connect(masterGain);
            
            reverbGain = audioCtx.createGain();
            reverbGain.gain.value = 0.8; 
            let delay = audioCtx.createDelay(); delay.delayTime.value = 0.5; 
            let fb = audioCtx.createGain(); fb.gain.value = 0.7;
            gainNode.connect(delay); delay.connect(fb); fb.connect(delay);
            delay.connect(reverbGain).connect(masterGain);
            
            distortionNode = audioCtx.createWaveShaper();
            distortionNode.curve = makeDistortionCurve(50);
            gainNode.connect(distortionNode);
            distortionNode.connect(masterGain);

            setInterval(() => {
                if(isRunning) {
                    let freq = 800 + Math.random() * 1500; 
                    radioOsc.frequency.setValueAtTime(freq, audioCtx.currentTime); 
                }
            }, 300);

            radioOsc.start(); whiteNoiseNode.start(); lfo.start();
            initSpeechRec();
        }
        
        function makeDistortionCurve(amount) {
            let k = typeof amount === 'number' ? amount : 50,
                n_samples = 44100,
                curve = new Float32Array(n_samples),
                deg = Math.PI / 180,
                i = 0, x;
            for ( ; i < n_samples; ++i ) {
                x = i * 2 / n_samples - 1;
                curve[i] = ( 3 + k ) * x * 20 * deg / ( Math.PI + k * Math.abs(x) );
            }
            return curve;
        }

        // SENSOR EMF
        function initSensor() {
            if (emfSimInterval) clearInterval(emfSimInterval); 
            
            if ('Magnetometer' in window) {
                try {
                    magnetometer = new Magnetometer({ frequency: 5 }); 
                    magnetometer.onreading = () => {
                        let strength = Math.sqrt(magnetometer.x**2 + magnetometer.y**2 + magnetometer.z**2);
                        emfValue = Math.min(100, (strength - 40) * 0.5); 
                        if (emfValue < 0) emfValue = 0;
                        if(sensorLed) sensorLed.classList.add('active-sensor'); 
                    };
                    magnetometer.onerror = (e) => {
                        console.warn("Error de Magnetómetro:", e.error.name, "Iniciando simulador.");
                        if(sensorLed) sensorLed.classList.remove('active-sensor'); 
                        startEmfSimulation(); 
                    };
                    magnetometer.start();
                    console.log("Sensor EMF (Magnetómetro) activado.");
                } catch(e) {
                    console.warn("No se pudo iniciar Magnetómetro. Iniciando simulador.");
                    if(sensorLed) sensorLed.classList.remove('active-sensor');
                    startEmfSimulation(); 
                }
            } else {
                console.warn("Magnetómetro no soportado. Iniciando simulador.");
                if(sensorLed) sensorLed.classList.remove('active-sensor');
                startEmfSimulation(); 
            }
        }
        
        function startEmfSimulation() {
            if (emfSimInterval) return;
            emfSimInterval = setInterval(() => {
                emfValue = Math.random() * 100;
            }, 200);
        }
        
        function stopSensor() {
            if (magnetometer) magnetometer.stop();
            if (emfSimInterval) clearInterval(emfSimInterval);
            emfSimInterval = null;
            emfValue = 0;
            if(sensorLed) sensorLed.classList.remove('active-sensor');
        }

        
        function startVisualLoop() {
            if (visualLoopInterval) clearInterval(visualLoopInterval); 
            visualLoopInterval = setInterval(() => {
                let intensity = emfValue; 
                
                let ledIntensity = Math.floor(intensity / 10); 
                updateLEDs(ledIntensity);
                updateEnergyGraph(intensity); 

                if(isRunning) {
                    document.getElementById('main-needle').style.transform = `translateX(-50%) rotate(${-45 + (intensity/100)*90}deg)`;
                    vuL.style.width = (intensity*0.6)+'%'; 
                    vuR.style.width = (intensity*0.6)+'%';
                }
            }, 150); 
        }
        
        function stopVisualLoop() {
            if (!isRunning) {
                document.getElementById('main-needle').style.transform = `translateX(-50%) rotate(-45deg)`;
                vuL.style.width = '0%'; 
                vuR.style.width = '0%';
            }
        }

        const pwr = document.getElementById('knob-power');
        pwr.addEventListener('click', () => {
            if(!audioCtx) initAudio();
            isRunning = !isRunning;
            
            if(isRunning) {
                pwr.style.transform = 'rotate(0deg)';
                pwr.style.boxShadow = '0 0 15px var(--glow-color)';
                detectorPanel.classList.add('retro-lit'); 
                
                if(audioCtx.state === 'suspended') audioCtx.resume();
                lfoGain.gain.linearRampToValueAtTime(0.05, audioCtx.currentTime+0.5);
                radioGain.gain.linearRampToValueAtTime(0.02, audioCtx.currentTime+0.5); 
                
                startAutoMode();
                
            } else {
                pwr.style.transform = 'rotate(-135deg)';
                pwr.style.boxShadow = 'none';
                detectorPanel.classList.remove('retro-lit');
                
                lfoGain.gain.linearRampToValueAtTime(0, audioCtx.currentTime+0.1);
                radioGain.gain.linearRampToValueAtTime(0, audioCtx.currentTime+0.1); 
                
                isRecognizing = false;
                window.speechSynthesis.cancel();
            }
            if (isRunning) {
            } else {
                stopVisualLoop(); 
            }
        });

        document.getElementById('knob-scan').addEventListener('click', function() {
            scanSpeed = (scanSpeed+1)%3;
            this.style.transform = `rotate(${-135 + scanSpeed*135}deg)`;
            if(lfo) lfo.frequency.linearRampToValueAtTime([5,12,20][scanSpeed], audioCtx.currentTime+0.1);
        });

        document.getElementById('vol-slider').addEventListener('input', (e) => {
            if(masterGain) masterGain.gain.value = e.target.value/100;
        });

        async function loadSheetData() {
            try {
                let [ra, rp] = await Promise.all([
                    fetch(`${SHEETDB_URL}?sheet=AUTOMATICO`), 
                    fetch(`${SHEETDB_URL}?sheet=PROGRAMADO`)
                ]);
                let ja = await ra.json(); automaticoData = ja.map(r=>r.TEXTO||r.texto).filter(t=>t);
                let jp = await rp.json();
                jp.forEach(r=>{
                    let p=(r.PREGUNTA||r.pregunta||"").toLowerCase().normalize("NFD").replace(/[\u0300-\u036f]/g,"");
                    let res=r.RESPUESTA||r.respuesta;
                    if(p&&res) programadoData.set(p,res);
                });
                console.log("Datos cargados:", automaticoData.length, programadoData.size);
            } catch(e){ console.error("Error datos", e); }
        }
        loadSheetData();

        function speak(text) {
            isSpeaking = true;
            
            lfoGain.gain.linearRampToValueAtTime(0.08, audioCtx.currentTime+0.1);
            lfo.frequency.linearRampToValueAtTime(15, audioCtx.currentTime + 0.1);
            radioGain.gain.linearRampToValueAtTime(0.01, audioCtx.currentTime+0.1);
            
            const u = new SpeechSynthesisUtterance(text);
            u.lang = 'es-MX'; 
            u.volume = 1.0; 
            u.pitch = 1.0; 
            u.rate = 1.1; 
            
            u.onend = () => {
                isSpeaking = false;
                lfoGain.gain.linearRampToValueAtTime(0.05, audioCtx.currentTime+0.2);
                lfo.frequency.linearRampToValueAtTime([5,12,20][scanSpeed], audioCtx.currentTime + 0.2);
                radioGain.gain.linearRampToValueAtTime(0.02, audioCtx.currentTime+0.2);
            };
            window.speechSynthesis.speak(u);
            
            sensorPanel.classList.add('alert');
            emfValue = 80 + Math.random() * 20; 
            setTimeout(() => sensorPanel.classList.remove('alert'), 500);
        }

        function startAutoMode() {
            if(!isRunning) return;
            setTimeout(() => {
                if(isRunning && !isSpeaking && automaticoData.length>0 && Math.random()>0.5) {
                    speak(automaticoData[Math.floor(Math.random()*automaticoData.length)]);
                }
                startAutoMode();
            }, 3000+Math.random()*4000);
        }

        function initSpeechRec() {
            if(!SpeechRecognition) return;
            recognition = new SpeechRecognition(); 
            recognition.lang = 'es-MX'; 
            recognition.continuous = false;
            recognition.onstart = () => { 
                isRecognizing = true;
                if(micLed) micLed.classList.add('active-mic'); 
            };
            
            recognition.onend = () => { 
                isRecognizing = false;
                if(micLed) micLed.classList.remove('active-mic'); 
            };
            
            recognition.onerror = () => {
                isRecognizing = false;
                if(micLed) micLed.classList.remove('active-mic');
            };
            recognition.onresult = (e) => {
                let t = e.results[0][0].transcript.toLowerCase().normalize("NFD").replace(/[\u0300-\u036f]/g,"");
                if(programadoData.has(t)) speak(programadoData.get(t));
            };
        }
        
        function persistentMicCheck(){ 
            if(isRunning && !isRecognizing && !isSpeaking) {
                try { 
                    recognition.start(); 
                } catch(e) { 
                    isRecognizing = false; 
                    if(micLed) micLed.classList.remove('active-mic');
                } 
            }
        }

        function updateLEDs(intensity) { 
            segments.forEach((seg, i) => { 
                seg.className = 'led-segment';
                if (i < intensity) {
                    if (i < 3) seg.classList.add('active-blue');
                    else if (i < 7) seg.classList.add('active-yellow');
                    else seg.classList.add('active-red');
                }
            });
        }

        function updateEnergyGraph(value) {
            if (!energyCtx || !energyCanvas) return; 
            
            energyHistory.push(value);
            if (energyHistory.length > 50) energyHistory.shift();

            let w = energyCanvas.width;
            let h = energyCanvas.height;
            if (w === 0 || h === 0) {
                resizeEnergyCanvas();
                w = energyCanvas.width;
                h = energyCanvas.height;
                if(w === 0 || h === 0) return;
            }
            
            energyCtx.clearRect(0, 0, w, h);
            let step = w / energyHistory.length;

            energyCtx.beginPath();
            energyCtx.strokeStyle = 'var(--glow-color)';
            energyCtx.lineWidth = 1;
            energyCtx.moveTo(0, h - (energyHistory[0] / 100 * h));
            for(let i=1; i<energyHistory.length; i++) {
                energyCtx.lineTo(i * step, h - (energyHistory[i] / 100 * h));
            }
            energyCtx.stroke();
            
            energyCtx.beginPath();
            energyCtx.strokeStyle = 'var(--alert-red)';
            energyCtx.lineWidth = 2; 
            let inPeak = false;
            for(let i=0; i<energyHistory.length; i++) {
                let val = energyHistory[i];
                let y = h - (val / 100 * h);
                
                if (val > 70) { 
                    if (!inPeak) {
                        energyCtx.moveTo(i * step, y);
                        inPeak = true;
                    } else {
                        energyCtx.lineTo(i * step, y);
                    }
                } else {
                    inPeak = false;
                }
            }
            energyCtx.stroke(); 
        }

        function resizeEnergyCanvas() {
            if(energyCanvas && energyCanvas.parentElement) {
                energyCanvas.width = energyCanvas.parentElement.offsetWidth;
                energyCanvas.height = energyCanvas.parentElement.offsetHeight;
            }
        }


        function updateSensorReadings() {
            currentTemp += (Math.random()*0.04 - 0.02); 
            document.getElementById('temp-val').innerText = currentTemp.toFixed(1)+"°C";
        }
        setInterval(updateSensorReadings, 2000);

        // --- UI Lógica Actualizada ---
        const menu = document.getElementById('menu-tools');
        let mT;
        document.getElementById('btn-ver').addEventListener('click', () => {
            menu.classList.toggle('visible');
            clearTimeout(mT);
            if(menu.classList.contains('visible')) mT = setTimeout(()=>menu.classList.remove('visible'), 5000);
        });
        
        function checkPanelState() {
            const p1 = document.getElementById('p-detector').classList.contains('hidden');
            const p2 = document.getElementById('p-env').classList.contains('hidden');
            
            if (!p1 || !p2) { 
                document.body.classList.add('panels-active');
            } else {
                document.body.classList.remove('panels-active');
            }
        }

        function togglePanel(id) {
            const p = document.getElementById(id);
            const btn = document.querySelector(`.menu-item[onclick="togglePanel('${id}')"]`);
            p.classList.toggle('hidden');
            if(btn) btn.classList.toggle('active');
            
            checkPanelState(); 
            
            menu.classList.remove('visible');
            
            if(id === 'p-env' && !p.classList.contains('hidden')) resizeEnergyCanvas();
        }

        window.onload = () => {
            startCamera();
            initSensor(); 
            startVisualLoop(); 
            initMLModel(); 
            
            setInterval(updateSensorReadings, 2000); 
            setInterval(persistentMicCheck, 1000); 
            
            document.getElementById('p-detector').classList.add('hidden');
            document.getElementById('p-env').classList.add('hidden');
            document.querySelector('#m-detector').classList.remove('active');
            document.querySelector('#m-env').classList.remove('active');
            checkPanelState();
        };
        
        window.onresize = () => {
            resizeAllCanvas(); 
            
            if(energyCanvas && !document.getElementById('p-env').classList.contains('hidden')) {
                resizeEnergyCanvas();
            }
        };
    </script>
</body>
</html>
