<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <link rel="apple-touch-icon" href="obr-logo.png">
    <title>DETECTOR-OBR</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=Orbitron:wght@500;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-core"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-converter"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgl"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection"></script>

    <style>
        :root {
    --neon-green: #39FF14; 
    --alert-red: #FF3333;
    --sim-orange: #FFB000;
    --sensor-blue: #00BFFF;
    --panel-bg: rgba(0, 20, 0, 0.4); /* Fondo de cristal oscuro */
    --border-color: rgba(57, 255, 20, 0.3);
    --border-strong: rgba(57, 255, 20, 0.7);
    --text-color: #E0E0E0;
    --text-dim: #999;
    
    /* --- üìç TAMA√ëOS DEL NUEVO HUD --- */
    --hud-bottom-height: 160px; /* Altura de la barra inferior */
    --hud-left-width: 100px; /* Ancho de la barra izquierda */
    --hud-gap: 15px; /* Espacio entre los bordes y las barras */
    --panel-section-padding: 6px;
}

body {
    font-family: 'Share Tech Mono', monospace;
    background-color: #000;
    color: var(--neon-green);
    overflow: hidden;
    width: 100vw;
    height: 100vh;
    display: flex; /* Para el layout principal de la app */
    justify-content: center;
    align-items: center;
}

#app-ui {
    position: relative;
    width: 100%;
    height: 100%;
    display: grid;
    /* üìç El dise√±o de cabina en L se define aqu√≠ */
    grid-template-areas:
        "left-panel camera-view"
        "left-panel bottom-panel"; /* Izquierda ocupa toda la altura */
    grid-template-columns: var(--hud-left-width) 1fr;
    grid-template-rows: 1fr var(--hud-bottom-height);
    background-color: #000; 
    touch-action: none; 
}

/* Contenedor de la c√°mara */
#main-view-area {
    grid-area: camera-view;
    position: relative; 
    overflow: hidden;
    z-index: 5;
    background: #000;
    transition: filter 0.3s ease-in-out;
}

/* Paneles de la Cabina en L */
#left-panel-container {
    grid-area: left-panel;
    background: var(--panel-bg);
    border-right: 1px solid var(--border-strong);
    box-shadow: 0 0 10px rgba(57, 255, 20, 0.2) inset, 0 0 8px rgba(57, 255, 20, 0.2);
    border-radius: 0 8px 8px 0; /* Bordes redondeados correctos */
    z-index: 20;
    display: flex;
    flex-direction: column;
    padding: var(--panel-section-padding);
    gap: var(--panel-section-padding);
    transition: transform 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94), opacity 0.4s ease-out;
    pointer-events: auto;
}

#bottom-panel-container {
    grid-area: bottom-panel;
    background: var(--panel-bg);
    border-top: 1px solid var(--border-strong);
    box-shadow: 0 0 10px rgba(57, 255, 20, 0.2) inset, 0 0 8px rgba(57, 255, 20, 0.2);
    border-radius: 8px 0 0 0; 
    z-index: 20;
    display: flex;
    flex-direction: row; 
    padding: var(--panel-section-padding);
    gap: var(--panel-section-padding);
    transition: transform 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94), opacity 0.4s ease-out;
    pointer-events: auto;
    align-items: center;
}

/* üìç Efecto de ocultar paneles y flotantes */
body.ui-hidden #left-panel-container {
    transform: translateX(-100%);
    opacity: 0;
    pointer-events: none;
}
body.ui-hidden #bottom-panel-container {
    transform: translateY(100%);
    opacity: 0;
    pointer-events: none;
}

/* üìç CORRECCI√ìN VNO (P2): Ahora es VERDE */
#main-view-area.filter-vno {
    filter: grayscale(1) contrast(1.5) brightness(1.2) sepia(1) hue-rotate(50deg) saturate(20);
}
#main-view-area.filter-neg {
    filter: invert(1) hue-rotate(180deg) brightness(1.1);
}

#bg-camera-feed {
    position: absolute;
    top: 50%;
    left: 50%;
    min-width: 100%; 
    min-height: 100%; 
    width: auto;
    height: auto;
    object-fit: cover; 
    transform: translate(-50%, -50%) scale(1);
    z-index: 1;
    transition: transform 0.3s ease-out;
}

#main-filter-canvas {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%; 
    height: 100%; 
    z-index: 10; 
    pointer-events: none; 
    display: none; 
}

.hidden-canvas { display: none; }
.hidden { display: none !important; }

/* --- Controles Flotantes sobre la c√°mara (LOGO, LINTERNA, FILTROS) --- */
#hud-floating-controls {
    position: absolute; 
    top: 0; left: 0; right: 0; bottom: 0;
    z-index: 101; 
    pointer-events: none; 
    opacity: 1;
    transition: opacity 0.4s ease-out;
}
body.ui-hidden #hud-floating-controls {
    opacity: 0;
    pointer-events: none;
}

#hud-top-logo {
    position: absolute;
    top: var(--hud-gap);
    right: var(--hud-gap);
    width: 60px; height: 60px;
    pointer-events: auto;
    animation: logo-effects 7s infinite linear; 
}

#hud-torch-button {
    position: absolute;
    top: var(--hud-gap);
    left: var(--hud-gap);
    width: 50px; height: 50px;
    background: rgba(0, 50, 50, 0.7);
    border: 2px solid var(--border-strong);
    color: var(--neon-green);
    border-radius: 50%;
    box-shadow: 0 0 10px rgba(57, 255, 20, 0.5);
    transition: all 0.2s;
    pointer-events: auto;
    display: flex;
    align-items: center;
    justify-content: center;
}
#hud-torch-button svg { width: 24px; height: 24px; fill: currentColor; }
#hud-torch-button:active, #hud-torch-button.active {
    background: var(--neon-green); color: #000; box-shadow: 0 0 20px #fff;
}

#hud-filter-controls {
    position: absolute;
    top: 50%;
    right: var(--hud-gap);
    transform: translateY(-50%);
    display: flex;
    flex-direction: column;
    gap: 10px;
    pointer-events: auto;
}
.filter-btn {
    width: 50px; height: 50px;
    border-radius: 50%;
    background: rgba(0, 50, 50, 0.7);
    border: 2px solid var(--border-strong);
    color: var(--neon-green);
    font-weight: bold; cursor: pointer;
    box-shadow: 0 0 10px rgba(57, 255, 20, 0.5);
    transition: all 0.2s;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 0.7rem;
}
.filter-btn:active, .filter-btn.active {
    background: var(--neon-green); color: #000; box-shadow: 0 0 20px #fff;
}

/* Animaciones para los elementos flotantes */
@keyframes popIn { 0% { transform: scale(0); opacity: 0; } 50% { transform: scale(1.2); } 100% { transform: scale(1); opacity: 1; } }
@keyframes logo-effects { 0%, 90% { transform: scale(1) translateY(0); opacity: 1; filter: none; } 91% { transform: scale(1.1) translateX(-5px); opacity: 0.8; filter: drop-shadow(2px 0 red) drop-shadow(-2px 0 blue); } 92% { transform: scale(0.9) translateX(5px); opacity: 1; filter: drop-shadow(-2px 0 red) drop-shadow(2px 0 blue); } 93% { transform: scale(1) translateY(0); opacity: 1; filter: none; } 94% { transform: scale(1) translateY(0); opacity: 0.5; filter: blur(2px); } 95% { transform: scale(1) translateY(0); opacity: 1; filter: none; } 96% { transform: scale(1) translateY(-3px); } 97% { transform: scale(1) translateY(3px); } 98%, 100% { transform: scale(1) translateY(0); } }
#hud-top-logo.hiding, #hud-torch-button.hiding, #hud-filter-controls.hiding { animation: waterDrop 0.5s ease-out forwards; }
@keyframes waterDrop { 0% { opacity: 1; transform: scale(1); filter: blur(0); } 100% { opacity: 0; transform: scale(2.5); filter: blur(5px); } }
@keyframes pulseGlow { 0%, 100% { opacity: 0.6; } 50% { opacity: 1.0; } }

/* --- Dise√±o de Secciones de Paneles --- */
.panel-section {
    border: 1px solid var(--border-color);
    border-radius: 4px;
    padding: var(--panel-section-padding);
    background: rgba(0, 0, 0, 0.2);
    display: flex;
    flex-direction: column;
    flex-shrink: 0;
}

.section-title {
    font-family: 'Orbitron', sans-serif;
    font-size: 0.6rem;
    color: var(--text-dim);
    text-transform: uppercase;
    margin-bottom: var(--panel-section-padding);
    text-align: center;
    border-bottom: 1px solid var(--border-color);
    padding-bottom: 3px;
    white-space: nowrap;
}

/* Contenido del Panel Izquierdo */
#left-panel-container .panel-section { flex-grow: 1; justify-content: space-between; }
#left-panel-container .sensor-status-grid {
    display: flex;
    flex-direction: column;
    gap: 10px;
    align-items: center;
}
.status-light-group { display: flex; flex-direction: column; align-items: center; font-size: 0.6rem; color: var(--text-dim); gap: 4px; }
.status-led-indicator { width: 12px; height: 12px; border-radius: 50%; background-color: #222; border: 1px solid #444; transition: all 0.3s; }
.status-light-group[data-status="connected"] .status-led-indicator { background-color: var(--neon-green); box-shadow: 0 0 8px var(--neon-green); animation: pulseGlow 1.5s infinite; }
.status-light-group[data-status="fallback"] .status-led-indicator { background-color: var(--sensor-blue); box-shadow: 0 0 8px var(--sensor-blue); animation: pulseGlow 1.5s infinite; }
.status-light-group[data-status="simulated"] .status-led-indicator { background-color: var(--sim-orange); box-shadow: 0 0 8px var(--sim-orange); animation: pulseGlow 2s infinite; }
.status-light-group[data-status="unavailable"] .status-led-indicator { background-color: var(--alert-red); box-shadow: 0 0 8px var(--alert-red); }
.status-light-group[data-status="off"] .status-led-indicator { background-color: #333; }
.status-light-group .emoji { font-size: 1.2rem; line-height: 1; }

#cam-stats-display {
    font-family: 'Orbitron', sans-serif;
    font-size: 0.7rem;
    font-weight: 700;
    color: var(--alert-red);
    text-align: center;
    animation: rec-pulse 1.5s infinite ease-in-out;
    cursor: default;
    margin-top: 10px; /* Separaci√≥n del resto */
}
@keyframes rec-pulse { 0%, 100% { opacity: 1; text-shadow: 0 0 8px var(--alert-red); } 50% { opacity: 0.7; text-shadow: 0 0 4px var(--alert-red); } }

/* Contenido del Panel Inferior */
#bottom-panel-container .panel-section {
    flex-direction: row; 
    flex-grow: 1;
    align-items: center;
    gap: 10px;
}
#bottom-panel-container .section-title {
    writing-mode: vertical-rl; 
    text-orientation: mixed;
    border-bottom: none;
    border-right: 1px solid var(--border-color);
    padding-bottom: 0;
    padding-right: 3px;
    font-size: 0.55rem; 
    flex-shrink: 0;
    height: 100%; 
    display: flex;
    align-items: center;
}

/* Lecturas de Campo */
.dials-grid {
    display: grid;
    grid-template-columns: 1fr 1.5fr 1fr; /* Br√∫jula | Detector | Temp */
    gap: 10px;
    align-items: center;
    justify-items: center;
    flex-grow: 1; 
}
.dial-container { position: relative; width: 65px; height: 65px; background: radial-gradient(circle, #111, #000); border-radius: 50%; border: 1px solid var(--border-color); box-shadow: 0 0 5px rgba(57, 255, 20, 0.3) inset; }
.dial-needle { width: 2px; height: 40%; background: var(--neon-green); box-shadow: 0 0 5px var(--neon-green); position: absolute; bottom: 50%; left: 50%; transform-origin: bottom center; transform: translateX(-50%) rotate(-45deg); transition: transform 0.5s cubic-bezier(0.2, 1.5, 0.5, 1); }
.dial-label { font-size: 0.6rem; color: var(--text-dim); margin-top: 4px; text-align: center; position: absolute; bottom: 5px; left: 0; right: 0; }

#detector-dial-container { width: 90px; height: 90px; } /* M√°s grande */
#detector-dial-needle { height: 45%; background: var(--alert-red); box-shadow: 0 0 8px var(--alert-red); transform: translateX(-50%) rotate(-60deg); }

#temp-readout { text-align: center; }
#temp-val { font-size: 1.8rem; font-family: 'Orbitron', sans-serif; color: var(--neon-green); line-height: 1; }
.temp-label { font-size: 0.6rem; color: var(--text-dim); }

/* Spirit Box */
.spirit-box-content {
    display: grid;
    grid-template-columns: auto 1fr auto; /* Pwr | Actividad | Vol */
    grid-template-rows: auto auto; /* Knobs arriba, graph/slider abajo */
    gap: 8px;
    flex-grow: 1;
    height: 100%;
}
.knob-container { display: flex; flex-direction: column; align-items: center; }
.knob-label { font-size: 0.6rem; color: var(--text-dim); margin-top: 4px; }
.knob-circle { width: 50px; height: 50px; border-radius: 50%; border: 2px solid var(--border-color); position: relative; cursor: pointer; background: radial-gradient(circle, #222, #000); box-shadow: 0 3px 5px #000, 0 0 5px rgba(57, 255, 20, 0.3) inset; transition: all 0.3s; }
.knob-circle.active { border-color: var(--neon-green); box-shadow: 0 3px 5px #000, 0 0 10px var(--neon-green) inset, 0 0 10px var(--neon-green); }
.knob-indicator { position: absolute; top: 6px; left: 50%; width: 3px; height: 15px; background: var(--neon-green); transform: translateX(-50%); border-radius: 2px; box-shadow: 0 0 5px var(--neon-green); }
#pwr-knob-indicator { height: 8px; width: 8px; border-radius: 50%; top: 8px; background: var(--alert-red); box-shadow: 0 0 5px var(--alert-red); }
#pwr-knob.active #pwr-knob-indicator { background: var(--neon-green); box-shadow: 0 0 8px var(--neon-green); }

#activity-graph-container {
    grid-column: 2 / 3; /* Ocupa la columna central */
    grid-row: 1 / 3; /* Ocupa ambas filas */
    height: 100%;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    background: #000; border: 1px solid var(--border-color); border-radius: 4px; overflow: hidden;
    min-width: 150px; /* Ancho m√≠nimo para la gr√°fica */
}
#energy-canvas { width: 100%; height: 100%; }

.volume-control-group {
    grid-column: 3 / 4; /* Columna derecha */
    grid-row: 1 / 3; /* Ocupa ambas filas */
    display: flex;
    flex-direction: column; /* Vertical */
    align-items: center;
    justify-content: center;
    gap: 8px;
    height: 100%;
}
.vol-label { font-size: 0.6rem; color: var(--text-dim); white-space: nowrap; }
#vol-percent { font-size: 0.6rem; color: var(--neon-green); width: 30px; text-align: center; }
input[type=range] { 
    -webkit-appearance: none; 
    width: 10px; 
    height: 80px; 
    background: #111; 
    border: 1px solid var(--border-color); 
    border-radius: 10px; 
    overflow: hidden; 
    transform: rotate(-90deg); 
    transform-origin: center;
    margin: 0; 
}
input[type=range]::-webkit-slider-thumb { 
    -webkit-appearance: none; 
    width: 20px; 
    height: 20px; 
    background: #444; 
    border: 1px solid #666; 
    border-radius: 50%; 
    box-shadow: -100vw 0 0 100vw var(--neon-green); 
    cursor: pointer; 
}

/* --- Pantalla de Carga y "S√≠guenos" --- */
#loading-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #000; z-index: 9999; display: flex; justify-content: center; align-items: center; transition: opacity 0.5s ease-out; }
#loading-content { text-align: center; }
#loading-text { font-family: 'Orbitron', sans-serif; font-size: 1.2rem; color: var(--neon-green); text-shadow: 0 0 10px var(--neon-green); animation: pulseGlow 2s infinite ease-in-out; transition: all 0.3s; }
#loading-bar-container { width: 250px; height: 10px; border: 1px solid var(--neon-green); border-radius: 5px; margin-top: 15px; overflow: hidden; background: rgba(0, 50, 50, 0.3); }
#loading-bar { width: 0%; height: 100%; background-color: var(--neon-green); transition: width 0.4s ease-out; animation: loading-shimmer 2s infinite linear; background-image: linear-gradient(90deg, var(--neon-green) 0%, #fff 50%, var(--neon-green) 100%); background-size: 200% 100%; }
@keyframes loading-shimmer { 0% { background-position: 200% 0; } 100% { background-position: -200% 0; } }

#follow-container { 
    position: fixed; 
    /* Se posiciona dentro del main-view-area */
    bottom: var(--hud-gap);
    left: 50%; 
    transform: translateX(-50%); 
    z-index: 100; /* Debajo de los botones flotantes */
    pointer-events: none; 
    opacity: 0; 
    width: 100%; 
    transition: opacity 0.5s ease-out; 
}
#follow-container.visible { opacity: 1; }
.follow-step { 
    display: none; 
    color: var(--neon-green); 
    font-size: 1.5rem; 
    font-family: 'Orbitron', sans-serif; 
    text-shadow: 0 0 10px var(--neon-green), 0 0 10px #000; /* Sombra negra para legibilidad */
    text-align: center; 
    opacity: 0; 
}
#follow-icons { display: flex; align-items: center; justify-content: center; gap: 15px; }
#follow-icons svg { width: 50px; height: 50px; fill: var(--neon-green); filter: drop-shadow(0 0 5px var(--neon-green)) drop-shadow(0 0 5px #000); }
.fade-in { animation: fadeIn 1s ease-out forwards; }
.fade-out { animation: fadeOut 1s ease-out forwards; }
@keyframes fadeIn { 0% { opacity: 0; transform: scale(0.8); } 100% { opacity: 1; transform: scale(1); } }
@keyframes fadeOut { 0% { opacity: 1; } 100% { opacity: 0; } }

/* --- Media Queries para Adaptabilidad --- */
/* MODO VERTICAL (PORTRAIT) */
@media (max-aspect-ratio: 1/1) {
    #app-ui {
        grid-template-areas:
            "left-panel"
            "camera-view"
            "bottom-panel";
        grid-template-columns: 1fr; /* Una sola columna */
        grid-template-rows: var(--hud-left-width) 1fr var(--hud-bottom-height);
    }

    #left-panel-container {
        border-right: none;
        border-bottom: 1px solid var(--border-strong);
        border-radius: 0 0 8px 8px; 
        width: 100%; 
        height: var(--hud-left-width); 
        flex-direction: row; 
        justify-content: space-around;
        align-items: center;
    }

    #left-panel-container .sensor-status-grid {
        flex-direction: row; 
        gap: 20px;
    }

    #left-panel-container .section-title {
        margin-bottom: 0;
        border-bottom: none;
        border-right: 1px solid var(--border-color);
        padding-bottom: 0;
        padding-right: 3px;
        writing-mode: vertical-rl; 
        height: 100%;
        font-size: 0.55rem;
    }
    #left-panel-container .panel-section {
        flex-grow: 1;
        flex-direction: row;
        justify-content: center;
        align-items: center;
        height: 100%;
    }
    #cam-stats-display {
        margin-top: 0; 
        margin-left: 10px; 
    }

    #bottom-panel-container {
        border-top: none;
        border-radius: 8px 8px 0 0; 
        width: 100%;
        flex-direction: column; 
        height: var(--hud-bottom-height);
    }
    #bottom-panel-container .panel-section { flex-direction: column; flex-grow: 1; }
    #bottom-panel-container .section-title {
        writing-mode: horizontal-tb; 
        border-right: none;
        border-bottom: 1px solid var(--border-color);
        padding-right: 0;
        padding-bottom: 3px;
        font-size: 0.6rem;
    }
    #bottom-panel-container .dials-grid { 
        grid-template-columns: 1fr 1.5fr 1fr; /* Mantener 3 columnas */
        width: 100%;
    }
    #detector-dial-container { width: 65px; height: 65px; } 
    #detector-dial-needle { height: 40%; }
    
    .spirit-box-content {
        grid-template-columns: 1fr 1fr; 
        grid-template-rows: auto auto; 
    }
    #activity-graph-container { grid-column: 1 / 3; grid-row: 1 / 2; height: 60px; } 
    .knob-container:nth-child(1) { grid-column: 1 / 2; grid-row: 2 / 3; }
    .volume-control-group { grid-column: 2 / 3; grid-row: 2 / 3; flex-direction: row; }
    input[type
    </style>
</head>
<body>
    <div id="loading-overlay">
    <div id="loading-content">
        <div id="loading-text">INICIANDO DETECTOR OBR</div>
        <div id="loading-bar-container">
            <div id="loading-bar"></div>
        </div>
    </div>
</div>

<div id="app-ui"> 

    <div id="left-panel-container" onclick="handlePanelClick(event)">
        <div class="panel-section">
            <div class="section-title">SENSORES</div>
            <div class="sensor-status-grid">
                <div class="status-light-group" id="mic-status" data-status="off">
                    <div class="status-led-indicator"></div>
                    <div class="emoji">üéôÔ∏è</div>
                    <span>MIC</span>
                </div>
                <div class="status-light-group" id="mag-status" data-status="off">
                    <div class="status-led-indicator"></div>
                    <div class="emoji">üß≠</div>
                    <span>MAG</span>
                </div>
                <div class="status-light-group" id="prox-status" data-status="off">
                    <div class="status-led-indicator"></div>
                    <div class="emoji">‚ö°</div>
                    <span>EMF</span>
                </div>
            </div>
            <div id="cam-stats-display">
                <span id="cam-fps">--</span> FPS<br><span id="cam-res">----</span>p
            </div>
        </div>
        
        <div class="panel-section">
            <div class="section-title">AMBIENTE</div>
            <div id="temp-readout">
                <div id="temp-val">--.-¬∞C</div>
            </div>
        </div>
    </div>

    <div id="main-view-area" onclick="handleUITap(event)">
        <video id="bg-camera-feed" playsinline autoplay muted></video>
        <canvas id="main-filter-canvas"></canvas>

        <div id="hud-floating-controls">
            <img id="hud-top-logo" src="obr-logo.png" alt="Logo OBR" class="visible">
            
            <button id="hud-torch-button" onclick="toggleTorch(event)">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path d="M342.6 38.6c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3L380.7 167H256c-17.7 0-32 14.3-32 32s14.3 32 32 32h124.7l-83.4 83.4c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0l144-144c12.5-12.5 12.5-32.8 0-45.3l-144-144zM160 80c0-17.7-14.3-32-32-32s-32 14.3-32 32v144H64c-17.7 0-32 14.3-32 32s14.3 32 32 32h32v144c0 17.7 14.3 32 32 32s32-14.3 32-32V288h32c17.7 0 32-14.3 32-32s-14.3-32-32-32H160V80z"/></svg>
            </button>

            <div id="hud-filter-controls">
                <button class="filter-btn" onclick="setFilter('vno')">VNO</button>
                <button class="filter-btn" onclick="setFilter('sls')">SLS</button>
                <button class="filter-btn" onclick="setFilter('neg')">NEG</button>
            </div>

            <div id="follow-container">
                <div id="follow-text" class="follow-step">S√çGUENOS EN</div>
                <div id="follow-icons" class="follow-step">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M448 209.9a210.1 210.1 0 0 1 -122.8-39.3V349.4A162.6 162.6 0 1 1 185 188.3V277.2a74.6 74.6 0 1 0 52.2 71.2V0l88 0a121.2 121.2 0 0 0 122.8 122.1v87.8z"/></svg>
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><path d="M549.7 124.1c-6.3-23.7-24.8-42.3-48.3-48.6C458.8 64 288 64 288 64S117.2 64 74.6 75.5c-23.5 6.3-42 24.9-48.3 48.6-11.4 42.9-11.4 132.3-11.4 132.3s0 89.4 11.4 132.3c6.3 23.7 24.8 42.3 48.3 48.6C117.2 448 288 448 288 448s170.8 0 213.4-11.5c23.5-6.3 42-24.9 48.3-48.6 11.4-42.9 11.4-132.3 11.4-132.3s0-89.4-11.4-132.3zM232 341.5V170.5l145.2 85.5-145.2 85.5z"/></svg>
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path d="M504 256C504 119 393 8 256 8S8 119 8 256c0 123.8 90.7 226.4 209.3 245V327.7h-63V256h63v-54.6c0-62.2 37-96.5 93.7-96.5 27.1 0 55.5 4.8 55.5 4.8v61h-31.3c-30.8 0-40.4 19.1-40.4 38.7V256h68.8l-11 71.7h-57.8V501C413.3 482.4 504 379.8 504 256z"/></svg>
                </div>
                <div id="follow-handle" class="follow-step">@EXPLORACIONESOBR</div>
            </div>
        </div>
    </div>

    <div id="bottom-panel-container" onclick="handlePanelClick(event)">
        <div class="panel-section">
            <div class="section-title">LECTURAS</div>
            <div class="dials-grid">
                <div id="mag-dial-container" class="dial-container">
                    <div id="compass-needle" class="dial-needle"></div>
                    <div class="dial-label">BR√öJULA</div>
                </div>
                <div id="detector-dial-container" class="dial-container">
                    <div id="detector-dial-needle" class="dial-needle"></div>
                    <div class="dial-label">DETECTOR</div>
                </div>
                <div id="temp-readout">
                    <div id="temp-val">--.-¬∞C</div>
                    <div class="temp-label">AMBIENTE</div>
                </div>
            </div>
        </div>
        <div class="panel-section">
            <div class="section-title">SPIRIT-BOX</div>
            <div class="spirit-box-content">
                <div class="knob-container">
                    <div class="knob-circle" id="knob-power">
                        <div id="pwr-knob-indicator" class="knob-indicator"></div>
                    </div>
                    <div class="knob-label">ENCENDER</div>
                </div>
                
                <div id="activity-graph-container" title="Gr√°fica de Actividad EMF">
                    <canvas id="energy-canvas"></canvas>
                </div>
                
                <div class="volume-control-group">
                    <span class="vol-label">VOL</span>
                    <input type="range" min="0" max="100" value="80" id="vol-slider">
                    <span id="vol-percent" class="vol-label">80%</span>
                </div>
            </div>
        </div>
    </div>
</div> <canvas id="temp-canvas" class="hidden-canvas"></canvas>
    <script>
        // üìç INICIO DE SCRIPT ANTI-CACH√â
(function() {
    if ('serviceWorker' in navigator) {
        navigator.serviceWorker.getRegistrations().then(function(registrations) {
            if (registrations.length) {
                console.log('[ANTI-CACHE] Des-registrando Service Workers...');
                for(let registration of registrations) { registration.unregister(); }
                console.log('[ANTI-CACHE] Service Workers eliminados. Recargando...');
                location.reload(true);
            } else { console.log('[ANTI-CACHE] No se encontraron Service Workers.'); }
        });
    }
    if (window.caches) {
        caches.keys().then(function(names) {
            for (let name of names) {
                console.log('[ANTI-CACHE] Eliminando cach√©:', name);
                caches.delete(name);
            }
        });
    }
})();
// üìç FIN DE SCRIPT ANTI-CACH√â

const GOOGLE_SCRIPT_URL = "https://script.google.com/macros/s/AKfycbzOf3crQxBdPylwMTAd34W-nBShN31MkIUtaMdKsZHMZVVniI2HjMesD6DpOlO363T1/exec";

let isRunning = false;
let currentFilter = 'none'; 
let scanSpeed = 0; 

const mainViewArea = document.getElementById('main-view-area');
const videoBg = document.getElementById('bg-camera-feed');

const mainFilterCanvas = document.getElementById('main-filter-canvas');
const mainFilterCtx = mainFilterCanvas.getContext('2d', { willReadFrequently: true });

const tempCanvas = document.getElementById('temp-canvas');

const micStatus = document.getElementById('mic-status');
const magStatus = document.getElementById('mag-status');
const proxStatus = document.getElementById('prox-status');

let energyHistory = new Array(50).fill(0);
let energyCanvas, energyCtx;

let audioCtx, masterGain;
let audioSource_Fondo1, gain_Fondo1, audioBuffer_Fondo1;
let audioSource_Fondo2, gain_Fondo2, audioBuffer_Fondo2;
let reverb, reverbGain, distortionNode;
let scanTimer = null; 

let isSpeaking = false; 
const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
let recognition, isRecognizing = false;
let programadoData = new Map();
let automaticoData = [];
let currentTemp = 19.8;

let proximitySensor, magnetometer, orientationSensor;

let emfValue = 0;
let emfSimInterval = null;
let visualLoopInterval; 

let poseDetector; 
let latestPoses = []; 
let isDetectingPose = false; 

let spiritBoxState = "OFF";
let spiritBoxTimeout = null;

let uiVisible = true; // El UI est√° visible al inicio

let zoom = 1.0;
let maxZoom = 5.0;
let initialPinchDist = 0;
let lastPan = { x: 0, y: 0 };
let currentPan = { x: 0, y: 0 };
let isPinching = false;
let isPanning = false;

let videoTrack;
let isTorchOn = false;
let lastFrameTime = 0;
let frameCount = 0;
let lastFpsUpdate = 0;

async function startCamera() {
    try {
        const constraints = {
            video: {
                facingMode: { ideal: "environment" },
                width: { ideal: 4096 }, 
                height: { ideal: 2160 },
                frameRate: { ideal: 60 }
            },
            audio: false
        };
        const stream = await navigator.mediaDevices.getUserMedia(constraints);
        
        videoTrack = stream.getVideoTracks()[0]; 
        
        if (videoTrack && typeof videoTrack.applyConstraints === 'function') {
            videoTrack.applyConstraints({
                advanced: [{ focusMode: 'continuous' }]
            }).catch(e => console.warn("No se pudo aplicar 'focusMode: continuous'", e));
            
            const capabilities = videoTrack.getCapabilities();
            if (!capabilities.torch) {
                document.getElementById('hud-torch-button').style.display = 'none';
            }
        }
        
        videoBg.srcObject = stream;
        videoBg.onloadedmetadata = () => {
            resizeAllCanvas(); 
            energyCanvas = document.getElementById('energy-canvas');
            if (energyCanvas) { 
                energyCtx = energyCanvas.getContext('2d');
                resizeEnergyCanvas();
            }
            
            try {
                const settings = videoTrack.getSettings();
                const res = settings.height || videoBg.videoHeight;
                document.getElementById('cam-res').innerText = `${res}`;
            } catch(e) {
                document.getElementById('cam-res').innerText = `${videoBg.videoHeight}`;
            }
            
            drawLoop(); 
        };
    } catch (e) { console.log("Error de c√°mara", e); }
}

function resizeAllCanvas() {
    const w = mainViewArea.clientWidth; 
    const h = mainViewArea.clientHeight; 
    
    mainFilterCanvas.width = w;
    mainFilterCanvas.height = h;
    
    if(energyCanvas) {
        resizeEnergyCanvas();
    }
}

async function initMLModel() {
    try {
        const model = poseDetection.SupportedModels.MoveNet;
        const detectorConfig = {
            modelType: poseDetection.movenet.modelType.MULTIPOSE_LIGHTNING,
            maxPoses: 6 
        };
        poseDetector = await poseDetection.createDetector(model, detectorConfig);
        console.log("MoveNet (IA Multi-Pose) cargado.");
    } catch (e) {
        console.error("Error al cargar modelo de IA:", e);
    }
}

// üìç BUCLE DE DIBUJO OPTIMIZADO (P1, P13)
async function drawLoop() {
    const now = performance.now();
    frameCount++;
    if (now - lastFpsUpdate > 1000) {
        const fps = frameCount;
        document.getElementById('cam-fps').innerText = fps;
        frameCount = 0;
        lastFpsUpdate = now;
    }

    // Solo dibuja si el canvas de SLS est√° activo
    if (mainFilterCanvas.style.display === 'block' && latestPoses) {
        const w = mainFilterCanvas.width;
        const h = mainFilterCanvas.height;
        mainFilterCtx.clearRect(0, 0, w, h);
        drawAllSkeletons(latestPoses); 
    }
    
    requestAnimationFrame(drawLoop);
}

async function detectPoseLoop() {
    while (true) {
        // Solo detecta si el filtro SLS est√° activo
        if (currentFilter === 'sls' && poseDetector && videoBg.readyState === videoBg.HAVE_ENOUGH_DATA) {
            if (!isDetectingPose) {
                isDetectingPose = true;
                const poses = await poseDetector.estimatePoses(videoBg); 
                latestPoses = poses; 
                isDetectingPose = false;
            }
            await new Promise(r => setTimeout(r, 100)); // 10 FPS
        } else {
            latestPoses = []; 
            await new Promise(r => setTimeout(r, 500));
        }
    }
}

const confidenceThreshold = 0.3; 
const skeletonMap = [
    ['left_shoulder', 'right_shoulder'], ['left_shoulder', 'left_elbow'],
    ['left_elbow', 'left_wrist'], ['right_shoulder', 'right_elbow'],
    ['right_elbow', 'right_wrist'], ['left_shoulder', 'left_hip'],
    ['right_shoulder', 'right_hip'], ['left_hip', 'right_hip'],
    ['left_hip', 'left_knee'], ['left_knee', 'left_ankle'],
    ['right_hip', 'right_knee'], ['right_knee', 'right_ankle']
];

// üìç CORRECCI√ìN SLS (P3): Colores hardcodeados
function drawAllSkeletons(poses) {
    const ctx = mainFilterCtx; 
    
    ctx.strokeStyle = '#39FF14'; // VERDE NE√ìN
    ctx.fillStyle = '#FF3333';   // ROJO ALERTA
    ctx.lineWidth = 4;           // M√ÅS GRUESAS
    ctx.filter = 'drop-shadow(0 0 6px #39FF14)'; // BRILLO VERDE

    const videoW = videoBg.videoWidth;
    const videoH = videoBg.videoHeight;
    const canvasW = mainFilterCanvas.width;
    const canvasH = mainFilterCanvas.height;
    
    const videoAspect = videoW / videoH;
    const canvasAspect = canvasW / canvasH;
    
    let scale, offsetX, offsetY;
    
    if (canvasAspect > videoAspect) {
        scale = canvasW / videoW;
        offsetX = 0;
        offsetY = (canvasH - videoH * scale) / 2;
    } else {
        scale = canvasH / videoH;
        offsetX = (canvasW - videoW * scale) / 2;
        offsetY = 0;
    }

    poses.forEach(pose => {
        if (pose.score > confidenceThreshold) {
            drawKeypoints(pose.keypoints, scale, offsetX, offsetY);
            drawConnections(pose.keypoints, scale, offsetX, offsetY);
        }
    });
    ctx.filter = 'none';
}

function drawKeypoints(keypoints, scale, offsetX, offsetY) {
    const ctx = mainFilterCtx;
    for (let i = 0; i < keypoints.length; i++) {
        const keypoint = keypoints[i];
        if (keypoint.score > confidenceThreshold) {
            ctx.beginPath();
            ctx.arc(keypoint.x * scale + offsetX, keypoint.y * scale + offsetY, 5, 0, 2 * Math.PI);
            ctx.fill();
        }
    }
}

function drawConnections(keypoints, scale, offsetX, offsetY) {
    const ctx = mainFilterCtx;
    const keypointMap = new Map();
    keypoints.forEach(keypoint => keypointMap.set(keypoint.name, keypoint));

    skeletonMap.forEach(connection => {
        const start = keypointMap.get(connection[0]);
        const end = keypointMap.get(connection[1]);
        if (start && end && start.score > confidenceThreshold && end.score > confidenceThreshold) {
            ctx.beginPath();
            ctx.moveTo(start.x * scale + offsetX, start.y * scale + offsetY);
            ctx.lineTo(end.x * scale + offsetX, end.y * scale + offsetY);
            ctx.stroke();
        }
    });
}

// üìç NUEVA L√ìGICA DE FILTROS (P1, P13)
function setFilter(f) {
    event.stopPropagation(); // Evitar que el clic active el show/hide
    document.querySelectorAll('.filter-btn').forEach(b => {
        b.classList.remove('active');
    });
    
    mainViewArea.classList.remove('filter-vno', 'filter-neg');
    mainFilterCanvas.style.display = 'none';
    
    if (currentFilter === f) {
        currentFilter = 'none'; // Desactivar
    } else {
        currentFilter = f;
        if (f === 'vno') {
            mainViewArea.classList.add('filter-vno');
        } else if (f === 'neg') {
            mainViewArea.classList.add('filter-neg');
        } else if (f === 'sls') {
            mainFilterCanvas.style.display = 'block';
        }
        // Marcar el bot√≥n como activo
        const targetBtn = event ? event.target.closest('.filter-btn') : null;
        if(targetBtn) targetBtn.classList.add('active');
    }
}

function setSensorStatus(sensorName, status) {
    let el;
    if (sensorName === 'mic') el = micStatus;
    else if (sensorName === 'mag') el = magStatus;
    else if (sensorName === 'prox') el = proxStatus;
    if (el) el.dataset.status = status;
}

async function toggleTorch(event) {
    event.stopPropagation(); // Evitar que el clic active el show/hide
    
    if (!videoTrack || typeof videoTrack.applyConstraints !== 'function') {
        document.getElementById('hud-torch-button').style.display = 'none';
        return;
    }
    try {
        isTorchOn = !isTorchOn;
        await videoTrack.applyConstraints({ advanced: [{ torch: isTorchOn }] });
        document.getElementById('hud-torch-button').classList.toggle('active', isTorchOn);
    } catch (e) {
        console.error("Error al activar linterna:", e);
        isTorchOn = false; 
        document.getElementById('hud-torch-button').classList.toggle('active', false);
        document.getElementById('hud-torch-button').style.display = 'none';
    }
}

// --- L√≥gica de Audio (Sin cambios) ---
async function loadAudio(url) {
    try {
        const response = await fetch(url);
        const arrayBuffer = await response.arrayBuffer();
        return await audioCtx.decodeAudioData(arrayBuffer);
    } catch (e) { console.error(`Error cargando audio: ${url}`, e); throw e; }
}
async function initAudio() {
    if (audioCtx) return;
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    masterGain = audioCtx.createGain();
    masterGain.connect(audioCtx.destination);
    try {
        updateLoadingProgress(55, "CARGANDO AUDIO...");
        [audioBuffer_Fondo1, audioBuffer_Fondo2] = await Promise.all([
            loadAudio('FONDO_1.mp3'),
            loadAudio('FONDO_2.mp3')
        ]);
        updateLoadingProgress(65, "AUDIO CARGADO");
    } catch (e) { console.error("Error al cargar audios de fondo:", e); updateLoadingProgress(65, "ERROR DE AUDIO"); return; }
    gain_Fondo1 = audioCtx.createGain(); gain_Fondo1.gain.value = 0; gain_Fondo1.connect(masterGain);
    gain_Fondo2 = audioCtx.createGain(); gain_Fondo2.gain.value = 0; gain_Fondo2.connect(masterGain);
    reverbGain = audioCtx.createGain(); reverbGain.gain.value = 0.8;
    let delay = audioCtx.createDelay(1.0); delay.delayTime.value = 0.5; 
    let fb = audioCtx.createGain(); fb.gain.value = 0.6;
    reverbGain.connect(delay); delay.connect(fb); fb.connect(delay);
    delay.connect(masterGain); 
    distortionNode = audioCtx.createWaveShaper(); distortionNode.curve = makeDistortionCurve(50);
    distortionNode.oversample = '4x'; distortionNode.connect(reverbGain);
    initSpeechRec();
}
function playFondo1() {
    if (!audioBuffer_Fondo1) return;
    if (audioSource_Fondo1) { try { audioSource_Fondo1.stop(); } catch(e){} }
    audioSource_Fondo1 = audioCtx.createBufferSource();
    audioSource_Fondo1.buffer = audioBuffer_Fondo1;
    audioSource_Fondo1.loop = true;
    audioSource_Fondo1.connect(gain_Fondo1);
    audioSource_Fondo1.start();
}
function playFondo2_Fragment() {
    if (!audioBuffer_Fondo2 || !isRunning || spiritBoxState !== "SCANNING") return;
    if (audioSource_Fondo2) { try { audioSource_Fondo2.stop(); } catch(e){} }
    audioSource_Fondo2 = audioCtx.createBufferSource();
    audioSource_Fondo2.buffer = audioBuffer_Fondo2;
    audioSource_Fondo2.connect(gain_Fondo2);
    const duration = audioBuffer_Fondo2.duration;
    const startTime = Math.random() * (duration - 2);
    const fragmentDuration = 0.8 + Math.random() * 1.2;
    audioSource_Fondo2.start(0, startTime, fragmentDuration);
    if (scanTimer) clearTimeout(scanTimer);
    scanTimer = setTimeout(playFondo2_Fragment, fragmentDuration * 1000 + (Math.random() * 300));
}
function makeDistortionCurve(amount) {
    let k = typeof amount === 'number' ? amount : 50, n_samples = 44100,
        curve = new Float32Array(n_samples), deg = Math.PI / 180, i = 0, x;
    for ( ; i < n_samples; ++i ) {
        x = i * 2 / n_samples - 1;
        curve[i] = ( 3 + k ) * x * 20 * deg / ( Math.PI + k * Math.abs(x) );
    }
    return curve;
}

// --- L√≥gica de Sensores (Sin cambios) ---
let sensorPermissionsRequested = false;
async function requestAllPermissions() {
    if (sensorPermissionsRequested) { initSensor(); return; }
    sensorPermissionsRequested = true;
    console.log("Solicitando permisos de sensores...");
    if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
        try {
            const status = await DeviceOrientationEvent.requestPermission();
            if (status === 'granted') { initSensor(); } 
            else { setSensorStatus('mag', 'unavailable'); setSensorStatus('prox', 'simulated'); startEmfSimulation(); }
        } catch (e) { console.warn("Error permiso orientaci√≥n", e); initSensor(); }
    } else { console.log("Permiso orientaci√≥n no requerido"); initSensor(); }
}
function initSensor() {
    if ('AbsoluteOrientationSensor' in window) {
        try {
            orientationSensor = new AbsoluteOrientationSensor({ frequency: 10 });
            orientationSensor.onreading = () => {
                let q = orientationSensor.quaternion;
                let yaw = Math.atan2(2 * (q[0] * q[1] + q[2] * q[3]), 1 - 2 * (q[1] * q[1] + q[2] * q[2])) * (180 / Math.PI);
                document.getElementById('compass-needle').style.transform = `translateX(-50%) rotate(${-yaw}deg)`;
                setSensorStatus('mag', 'connected');
            };
            orientationSensor.onerror = (e) => { setSensorStatus('mag', 'unavailable'); };
            orientationSensor.start();
        } catch (e) { setSensorStatus('mag', 'unavailable'); }
    } else { setSensorStatus('mag', 'unavailable'); }
    if ('Magnetometer' in window) {
        try {
            magnetometer = new Magnetometer({ frequency: 10 });
            magnetometer.onreading = () => {
                let strength = Math.sqrt(magnetometer.x**2 + magnetometer.y**2 + magnetometer.z**2);
                emfValue = Math.min(100, (strength / 100) * 100); 
                setSensorStatus('prox', 'connected');
            };
            magnetometer.onerror = (e) => { initProximitySensor(); };
            magnetometer.start();
        } catch (e) { initProximitySensor(); }
    } else { initProximitySensor(); }
}
function initProximitySensor() {
    if ('ProximitySensor' in window) {
        try {
            proximitySensor = new ProximitySensor();
            proximitySensor.onreading = () => {
                const maxDist = 10, minDist = 2;  
                let dist = proximitySensor.value;
                if (dist <= minDist) emfValue = 100;
                else if (dist >= maxDist) emfValue = 0;
                else emfValue = 100 * (1 - (dist - minDist) / (maxDist - minDist));
                setSensorStatus('prox', 'fallback');
            };
            proximitySensor.onerror = (e) => { setSensorStatus('prox', 'simulated'); startEmfSimulation(); };
            proximitySensor.start();
        } catch(e) { setSensorStatus('prox', 'simulated'); startEmfSimulation(); }
    } else { setSensorStatus('prox', 'simulated'); startEmfSimulation(); }
}
function startEmfSimulation() {
    if (emfSimInterval) return;
    emfSimInterval = setInterval(() => { emfValue = Math.random() * 100; }, 200);
}
function stopSensor() {
    if (proximitySensor) proximitySensor.stop();
    if (magnetometer) magnetometer.stop();
    if (orientationSensor) orientationSensor.stop();
    if (emfSimInterval) clearInterval(emfSimInterval);
    emfSimInterval = null; emfValue = 0;
    setSensorStatus('prox', 'off'); setSensorStatus('mag', 'off');
}

function startVisualLoop() {
    if (visualLoopInterval) clearInterval(visualLoopInterval); 
    visualLoopInterval = setInterval(() => {
        let intensity = emfValue; 
        const needle = document.getElementById('detector-dial-needle');
        if (needle) {
            needle.style.transform = `translateX(-50%) rotate(${-60 + (intensity/100)*120}deg)`;
        }
        updateEnergyGraph(intensity); 
    }, 150); 
}

// --- L√≥gica Spirit Box (Sin cambios) ---
const pwr = document.getElementById('knob-power');
pwr.addEventListener('click', async (e) => {
    e.stopPropagation();
    if(!audioCtx) await initAudio();
    if(!audioCtx) return; 
    isRunning = !isRunning;
    pwr.classList.toggle('active', isRunning);
    if(isRunning) {
        pwr.style.transform = 'rotate(0deg)';
        if(audioCtx.state === 'suspended') {
            audioCtx.resume();
            const silentUtterance = new SpeechSynthesisUtterance(" ");
            silentUtterance.volume = 0; window.speechSynthesis.speak(silentUtterance);
        }
        playFondo1();
        gain_Fondo1.gain.linearRampToValueAtTime(0.3, audioCtx.currentTime + 0.5);
        gain_Fondo2.gain.linearRampToValueAtTime(0.7, audioCtx.currentTime + 0.5);
        requestAllPermissions();
        spiritBoxState = "SCANNING";
        playFondo2_Fragment();
        runSpiritBoxLoop();
    } else {
        pwr.style.transform = 'rotate(135deg)';
        gain_Fondo1.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.1);
        gain_Fondo2.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.1);
        if (audioSource_Fondo1) { try { audioSource_Fondo1.stop(); } catch(e){} }
        if (audioSource_Fondo2) { try { audioSource_Fondo2.stop(); } catch(e){} }
        if (scanTimer) clearTimeout(scanTimer);
        spiritBoxState = "OFF";
        if (spiritBoxTimeout) clearTimeout(spiritBoxTimeout);
        if (isRecognizing) recognition.abort();
        window.speechSynthesis.cancel();
        isSpeaking = false; isRecognizing = false;
        setSensorStatus('mic', 'off');
        stopSensor();
    }
});
document.getElementById('knob-scan').addEventListener('click', function(e) {
    e.stopPropagation();
    scanSpeed = (scanSpeed+1)%3;
    this.style.transform = `rotate(${-135 + scanSpeed*135}deg)`;
});
document.getElementById('vol-slider').addEventListener('input', (e) => {
    e.stopPropagation();
    const vol = e.target.value;
    if(masterGain) masterGain.gain.value = vol/100;
    document.getElementById('vol-percent').innerText = `${vol}%`;
});
function hideLoadingScreen() {
    const overlay = document.getElementById('loading-overlay');
    if (overlay) {
        overlay.style.opacity = '0';
        setTimeout(() => { overlay.style.display = 'none'; }, 500); 
    }
}
const loadingText = document.getElementById('loading-text');
const loadingBar = document.getElementById('loading-bar');
function updateLoadingProgress(percent, text) {
    if (loadingBar) loadingBar.style.width = percent + '%';
    if (loadingText) loadingText.innerText = `${text} [ ${percent}% ]`;
}
async function loadSheetData() {
    try {
        updateLoadingProgress(25, "CONECTANDO CON API-OBR");
        const response = await fetch(GOOGLE_SCRIPT_URL);
        updateLoadingProgress(50, "RECIBIENDO DATOS");
        if (!response.ok) throw new Error(`Error de red: ${response.statusText}`);
        const data = await response.json();
        if (!audioCtx) await initAudio(); 
        updateLoadingProgress(75, "PROCESANDO RESPUESTAS");
        automaticoData = data.automatico.map(r => r.TEXTO).filter(t => t);
        data.programado.forEach(r => {
            let p = (r.PREGUNTA || "").toLowerCase().normalize("NFD").replace(/[\u0300-\u036f]/g, "");
            let res = r.RESPUESTA;
            if (p && res) { programadoData.set(p, res); }
        });
        updateLoadingProgress(100, "SINCRONIZACI√ìN COMPLETA");
        console.log(`%c[SISTEMA OBR] Sincronizaci√≥n completa: ${automaticoData.length} AUTO | ${programadoData.size} PROG.`, "color: #39FF14; font-weight: bold;");
    } catch (e) { 
        console.error("Error cargando datos de Google Apps Script", e); 
        updateLoadingProgress(100, "ERROR DE SINCRONIZACI√ìN");
    } finally {
        setTimeout(hideLoadingScreen, 500); 
    }
}
function speak(text) {
    if (!text || isSpeaking) return;
    spiritBoxState = "SPEAKING";
    isSpeaking = true;
    if (scanTimer) clearTimeout(scanTimer);
    const words = text.split(' ');
    let wordIndex = 0;
    function speakWordByWord() {
        if (wordIndex >= words.length || !isRunning) {
            isSpeaking = false; spiritBoxState = "SCANNING";
            gain_Fondo1.gain.linearRampToValueAtTime(0.3, audioCtx.currentTime + 0.2);
            gain_Fondo2.gain.linearRampToValueAtTime(0.7, audioCtx.currentTime + 0.2);
            if (isRunning) { playFondo2_Fragment(); setTimeout(runSpiritBoxLoop, 2000); }
            return;
        }
        const word = words[wordIndex];
        const u = new SpeechSynthesisUtterance(word);
        u.lang = 'es-MX'; u.volume = 1.0;
        u.pitch = 0.1 + Math.random() * 0.7;
        u.rate = 0.9 + Math.random() * 0.4;
        u.onstart = () => {
            gain_Fondo1.gain.linearRampToValueAtTime(0.1, audioCtx.currentTime); 
            gain_Fondo2.gain.linearRampToValueAtTime(0.05, audioCtx.currentTime);
        };
        u.onend = () => {
            wordIndex++;
            gain_Fondo1.gain.linearRampToValueAtTime(0.3, audioCtx.currentTime);
            gain_Fondo2.gain.linearRampToValueAtTime(0.7, audioCtx.currentTime);
            setTimeout(speakWordByWord, 100 + Math.random() * 400);
        };
        window.speechSynthesis.speak(u);
    }
    speakWordByWord();
    emfValue = 80 + Math.random() * 20;
}
function runSpiritBoxLoop() {
    if (!isRunning || spiritBoxState === "SPEAKING") return;
    spiritBoxState = "LISTENING";
    if (audioSource_Fondo2) { try { audioSource_Fondo2.stop(); } catch(e){} }
    if (scanTimer) clearTimeout(scanTimer);
    gain_Fondo2.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.2);
    try { if (!isRecognizing) recognition.start(); } 
    catch(e) { console.warn("Error recognition", e); setSensorStatus('mic', 'unavailable'); if (isRunning) setTimeout(runSpiritBoxLoop, 2000); return; }
    spiritBoxTimeout = setTimeout(() => {
        if (spiritBoxState !== "LISTENING") return; 
        console.log("Timeout: No se detect√≥ comando.");
        if (isRecognizing) recognition.abort();
        isRecognizing = false;
        gain_Fondo2.gain.linearRampToValueAtTime(0.7, audioCtx.currentTime + 0.2);
        spiritBoxState = "SCANNING";
        playFondo2_Fragment(); 
        if (automaticoData.length > 0) {
            setTimeout(() => {
                if (isRunning) { speak(automaticoData[Math.floor(Math.random() * automaticoData.length)]); }
            }, 1000 + Math.random() * 2000);
        } else { setTimeout(runSpiritBoxLoop, 3000); }
    }, 5000);
}
function initSpeechRec() {
    if(!SpeechRecognition) { setSensorStatus('mic', 'unavailable'); return; }
    recognition = new SpeechRecognition(); 
    recognition.lang = 'es-MX'; recognition.continuous = false;
    recognition.onstart = () => { isRecognizing = true; setSensorStatus('mic', 'connected'); };
    recognition.onend = () => { isRecognizing = false; setSensorStatus('mic', 'off'); };
    recognition.onerror = (e) => { isRecognizing = false; setSensorStatus('mic', 'unavailable'); console.warn("Error Rec:", e.error); };
    recognition.onresult = (e) => {
        if (spiritBoxTimeout) clearTimeout(spiritBoxTimeout); 
        let t = e.results[0][0].transcript.toLowerCase().normalize("NFD").replace(/[\u0300-\u036f]/g,"");
        console.log("Comando detectado:", t);
        if (programadoData.has(t)) { speak(programadoData.get(t)); } 
        else { if (automaticoData.length > 0) { speak(automaticoData[Math.floor(Math.random() * automaticoData.length)]); } }
    };
}
function updateEnergyGraph(value) {
    if (!energyCtx || !energyCanvas) return; 
    energyHistory.push(value);
    if (energyHistory.length > 50) energyHistory.shift();
    let w = energyCanvas.width; let h = energyCanvas.height;
    if (w === 0 || h === 0) { resizeEnergyCanvas(); w = energyCanvas.width; h = energyCanvas.height; if(w === 0 || h === 0) return; }
    energyCtx.clearRect(0, 0, w, h);
    let step = w / energyHistory.length;
    energyCtx.beginPath(); energyCtx.strokeStyle = '#39FF14'; energyCtx.lineWidth = 1.5;
    energyCtx.moveTo(0, h - (energyHistory[0] / 100 * h));
    for(let i=1; i<energyHistory.length; i++) { energyCtx.lineTo(i * step, h - (energyHistory[i] / 100 * h)); }
    energyCtx.stroke();
    energyCtx.beginPath(); energyCtx.strokeStyle = '#FF3333'; energyCtx.lineWidth = 1; 
    let inPeak = false;
    for(let i=0; i<energyHistory.length; i++) {
        let val = energyHistory[i]; let y = h - (val / 100 * h);
        if (val > 80) { if (!inPeak) { energyCtx.moveTo(i * step, y); inPeak = true; } else { energyCtx.lineTo(i * step, y); } } 
        else { inPeak = false; }
    }
    energyCtx.stroke(); 
}
function resizeEnergyCanvas() {
    if(energyCanvas && energyCanvas.parentElement) {
        // Asignar dimensiones basadas en el contenedor
        const rect = energyCanvas.parentElement.getBoundingClientRect();
        if (rect.width > 0 && rect.height > 0) {
            energyCanvas.width = rect.width;
            energyCanvas.height = rect.height;
        }
    }
}
function updateSensorReadings() {
    if (!isRunning) {
        currentTemp += (Math.random()*0.04 - 0.02); 
        document.getElementById('temp-val').innerText = currentTemp.toFixed(1)+"¬∞C";
    }
}

// --- üìç L√ìGICA DE UI (P5, P14) ---

const followContainer = document.getElementById('follow-container');
const floatingControls = document.getElementById('hud-floating-controls');

// Clic en el fondo de la c√°mara
function handleUITap(event) {
    requestAllPermissions(); // Activar sensores en el primer toque
    if (isPinching || isPanning) return; // No hacer nada si es zoom
    
    if (uiVisible) { hideControls(); } 
    else { showControls(); }
}

// Clic en los paneles de cabina (para evitar que se cierren)
function handlePanelClick(event) {
    event.stopPropagation();
}

function showControls() {
    document.body.classList.remove('ui-hidden');
    floatingControls.classList.remove('hiding');
    followContainer.classList.remove('visible');
    uiVisible = true;
    
    // Iniciar animaci√≥n de "S√≠guenos" solo si la UI est√° visible y no est√° el panel
    setTimeout(() => {
        if(uiVisible) runFollowAnimation();
    }, 15000); // Iniciar despu√©s de 15 seg
}

function hideControls() {
    document.body.classList.add('ui-hidden');
    floatingControls.classList.add('hiding');
    followContainer.classList.add('visible'); // Mostrar "S√≠guenos" cuando la UI se oculta
    uiVisible = false;
}

// --- Animaci√≥n "S√≠guenos" ---
const followSteps = document.querySelectorAll('.follow-step');
let followAnimationRunning = false;
async function runFollowAnimation() {
    // Solo correr si la UI est√° visible (paneles ocultos) y no est√° ya corriendo
    if (document.body.classList.contains('ui-hidden') || followAnimationRunning) return; 
    
    followAnimationRunning = true;
    followContainer.classList.add('visible'); 
    
    const text = document.getElementById('follow-text');
    text.style.display = 'block'; text.classList.add('fade-in');
    await new Promise(r => setTimeout(r, 2500)); 
    if(!uiVisible) { followContainer.classList.remove('visible'); followAnimationRunning = false; return; } 
    text.classList.remove('fade-in'); text.classList.add('fade-out'); 
    await new Promise(r => setTimeout(r, 1000));
    text.style.display = 'none'; text.classList.remove('fade-out');
    
    const icons = document.getElementById('follow-icons');
    icons.style.display = 'flex'; icons.classList.add('fade-in');
    await new Promise(r => setTimeout(r, 2500)); 
    if(!uiVisible) { followContainer.classList.remove('visible'); followAnimationRunning = false; return; } 
    icons.classList.remove('fade-in'); icons.classList.add('fade-out');
    await new Promise(r => setTimeout(r, 1000));
    icons.style.display = 'none'; icons.classList.remove('fade-out');

    const handle = document.getElementById('follow-handle');
    handle.style.display = 'block'; handle.classList.add('fade-in');
    await new Promise(r => setTimeout(r, 2500)); 
    if(!uiVisible) { followContainer.classList.remove('visible'); followAnimationRunning = false; return; } 
    handle.classList.remove('fade-in'); handle.classList.add('fade-out');
    await new Promise(r => setTimeout(r, 1000));
    handle.style.display = 'none'; handle.classList.remove('fade-out');

    followContainer.classList.remove('visible');
    followAnimationRunning = false;
}

// --- L√≥gica de Zoom/Pan (P5) ---
const appUI = document.getElementById('app-ui');
function getPinchDist(e) {
    const t1 = e.touches[0]; const t2 = e.touches[1];
    return Math.sqrt(Math.pow(t1.clientX - t2.clientX, 2) + Math.pow(t1.clientY - t2.clientY, 2));
}
function getPanCenter(e) { return { x: e.touches[0].clientX, y: e.touches[0].clientY }; }
appUI.addEventListener('touchstart', (e) => {
    // Solo permitir zoom/pan si el toque es en el √°rea de la c√°mara
    if (!e.target.closest('#main-view-area')) return;

    if (e.touches.length === 2) {
        isPinching = true; isPanning = false;
        initialPinchDist = getPinchDist(e);
    } else if (e.touches.length === 1 && zoom > 1) {
        isPinching = false; isPanning = true;
        lastPan = getPanCenter(e);
    }
});
appUI.addEventListener('touchmove', (e) => {
    if (!e.target.closest('#main-view-area')) return;
    
    if (isPinching && e.touches.length === 2) {
        e.preventDefault(); // Prevenir scroll/refresh
        const newPinchDist = getPinchDist(e);
        const zoomFactor = newPinchDist / initialPinchDist;
        let newZoom = zoom * zoomFactor;
        newZoom = Math.max(1.0, Math.min(newZoom, maxZoom));
        zoom = newZoom;
        initialPinchDist = newPinchDist;
        videoBg.style.transform = `translate(-50%, -50%) scale(${zoom})`;
    }
    // (Panning desactivado por simplicidad, el zoom con scale() centra)
});
appUI.addEventListener('touchend', (e) => {
    if (e.touches.length < 2) isPinching = false;
    if (e.touches.length < 1) isPanning = false;
    if (zoom === 1) {
        videoBg.style.transform = `translate(-50%, -50%) scale(1)`;
    }
});

// --- Carga Inicial ---
window.onload = () => {
    startCamera();
    startVisualLoop(); 
    initMLModel(); 
    detectPoseLoop(); 
    
    setInterval(updateSensorReadings, 2000); 
    // Iniciar animaci√≥n de "S√≠guenos" 15s despu√©s de cargar
    setTimeout(runFollowAnimation, 15000); 
    
    showControls(); // Mostrar UI al inicio
    
    loadSheetData();
    resizeAllCanvas(); // Asegurar que los canvas tengan tama√±o
};

window.onresize = () => {
    resizeAllCanvas(); 
};
    </script>
</body>
</html>
