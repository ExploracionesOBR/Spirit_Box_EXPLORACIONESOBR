<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spirit Box OBR</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Share+Tech+Mono&display=swap" rel="stylesheet">
    <style>
        /* Estilos para el diseño retro */
        body {
            font-family: 'Share Tech Mono', monospace;
            background-color: #D7C6B4; /* Fondo beige retro */
            background-image: linear-gradient(rgba(0,0,0,0.05) 2px, transparent 2px),
                              linear-gradient(90deg, rgba(0,0,0,0.05) 2px, transparent 2px),
                              linear-gradient(rgba(0,0,0,0.03) 1px, transparent 1px),
                              linear-gradient(90deg, rgba(0,0,0,0.03) 1px, transparent 1px);
            background-size: 100px 100px, 100px 100px, 20px 20px, 20px 20px;
            background-position: -2px -2px, -2px -2px, -1px -1px, -1px -1px;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            color: #3A3A3A;
        }
        .spirit-box {
            width: 95%;
            max-width: 400px;
            background-color: #C0A996; /* Plástico principal */
            border: 4px solid #4D433A; /* Borde oscuro */
            border-radius: 10px;
            box-shadow: 0 10px 20px rgba(0,0,0,0.3), inset 0 0 15px rgba(0,0,0,0.2);
            padding: 20px;
        }
        .placa {
            background-color: #BDBDBD; /* Metal */
            border: 2px solid #5D5D5D;
            border-radius: 4px;
            padding: 10px;
            text-align: center;
            margin-bottom: 20px;
            box-shadow: inset 0 0 5px rgba(0,0,0,0.2);
            position: relative;
        }
        /* "Tornillos" de la placa */
        .placa::before, .placa::after {
            content: '';
            position: absolute;
            width: 8px;
            height: 8px;
            background: #5D5D5D;
            border-radius: 50%;
            top: 5px;
        }
        .placa::before { left: 5px; }
        .placa::after { right: 5px; }
        
        .placa h1 {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.2rem;
            color: #2A2A2A;
            text-shadow: 1px 1px 0px #F0F0F0;
            margin: 0;
            line-height: 1.1;
        }
        .placa p {
            font-size: 0.9rem;
            color: #3A3A3A;
            margin: 0;
        }

        .display-area {
            background: #333;
            border: 3px solid #555;
            border-radius: 5px;
            padding: 15px;
            margin-bottom: 20px;
            box-shadow: inset 0 0 10px #000;
        }
        .freq-display {
            font-family: 'Orbitron', sans-serif;
            font-size: 2.8rem;
            color: #FF4136; /* Rojo LED */
            text-align: center;
            text-shadow: 0 0 5px #FF4136, 0 0 10px #FF4136, 0 0 15px #FF4136, 0 0 20px #FF4136;
            margin-bottom: 10px;
        }
        .text-display {
            font-family: 'Share Tech Mono', monospace;
            font-size: 1.2rem;
            color: #F0F0F0; /* Texto blanco-gris */
            background-color: #222;
            border: 1px solid #444;
            border-radius: 3px;
            text-align: center;
            padding: 8px;
            height: 40px; /* Altura fija */
            line-height: 1.5;
            overflow: hidden;
            white-space: nowrap;
        }
        
        .controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }
        
        /* Botón de Encendido Retro */
        .power-button {
            grid-column: 1 / -1; /* Ocupa todo el ancho */
            font-family: 'Orbitron', sans-serif;
            font-size: 1.5rem;
            color: white;
            padding: 15px 20px;
            border: 3px solid #333;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            text-shadow: 0 0 5px white, 0 0 10px white;
        }
        
        .power-button.off {
            background-color: #B73229; /* Rojo oscuro */
            box-shadow: 0 5px 0 #6B1D18, 0 8px 10px rgba(0,0,0,0.3), inset 0 0 10px rgba(0,0,0,0.3);
        }
        .power-button.off:active {
            box-shadow: 0 2px 0 #6B1D18, 0 4px 5px rgba(0,0,0,0.3), inset 0 0 10px rgba(0,0,0,0.3);
            transform: translateY(3px);
        }
        
        .power-button.on {
            background-color: #FF4136; /* Rojo brillante */
            box-shadow: 0 5px 0 #A82C23, 0 8px 10px rgba(255,65,54,0.4), 
                        inset 0 0 10px rgba(255,255,255,0.5), 
                        0 0 20px #FF4136;
        }
        .power-button.on:active {
            box-shadow: 0 2px 0 #A82C23, 0 4px 5px rgba(255,65,54,0.4), 
                        inset 0 0 10px rgba(255,255,255,0.5),
                        0 0 20px #FF4136;
            transform: translateY(3px);
        }
        
        /* Slider de Velocidad */
        .slider-control {
            grid-column: 1 / -1; /* Ocupa todo el ancho */
            text-align: center;
            background: #AB9887;
            padding: 10px;
            border-radius: 5px;
            border: 2px solid #4D433A;
        }
        .slider-control label {
            display: block;
            font-size: 0.9rem;
            font-weight: bold;
            color: #3A3A3A;
            margin-bottom: 5px;
        }
        input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            height: 15px;
            background: #4D433A;
            border-radius: 5px;
            outline: none;
            opacity: 0.7;
            transition: opacity .2s;
        }
        input[type="range"]:hover {
            opacity: 1;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 25px;
            height: 25px;
            background: #FF4136;
            border: 3px solid #333;
            border-radius: 50%;
            cursor: pointer;
        }
        input[type="range"]::-moz-range-thumb {
            width: 25px;
            height: 25px;
            background: #FF4136;
            border: 3px solid #333;
            border-radius: 50%;
            cursor: pointer;
        }
    </style>
</head>
<body class="antialiased">

    <div class="spirit-box">
        
        <!-- Placa Laminada -->
        <div class="placa">
            <h1>EXPLORACIONES OBR</h1>
            <p>SPIRIT BOX</p>
        </div>

        <!-- Displays -->
        <div class="display-area">
            <div id="freq-display" class="freq-display">88.1</div>
            <div id="text-display" class="text-display">&nbsp;</div>
        </div>

        <!-- Controles -->
        <div class="controls">
            <!-- Botón de Encendido -->
            <button id="power-button" class="power-button off">ENCENDER</button>

            <!-- Control de Velocidad -->
            <div class="slider-control">
                <label for="speed-slider">SCAN SPEED</label>
                <input type="range" id="speed-slider" min="100" max="1000" value="600" step="50">
            </div>
        </div>

    </div>

    <script>
        // --- URLs y Configuración ---
        const SHEETDB_BASE_URL = "https://sheetdb.io/api/v1/9xzfnke69kkej";

        // --- Elementos del DOM ---
        const btnPower = document.getElementById('power-button');
        const freqDisplay = document.getElementById('freq-display');
        const textDisplay = document.getElementById('text-display');
        const speedSlider = document.getElementById('speed-slider');

        // --- Estado de la App ---
        let isRunning = false;
        let isLoaded = false;
        let programadoData = new Map();
        let automaticoData = [];
        let baseDelay = 600; // Delay default (valor del slider)

        // --- Módulos de Audio ---
        let audioContext;
        let gainNode;
        let whiteNoiseNode;
        let blipOscillator;
        let blipGain;

        // --- Módulos de Voz ---
        let voices = [];
        const synthesis = window.speechSynthesis;
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        let recognition;
        
        // --- Estado de los Ciclos ---
        let autoTimeout, freqTimeout;
        let crackleInterval = null; 
        let isProgrammedResponse = false; // Flag para controlar reinicio
        let isRecognizing = false; // Flag para prevenir 'start' duplicado
        let recognitionWatchdog; // Vigilancia para el micrófono

        // --- 0. Función de Utilidad (Normalizar Texto) ---
        function normalizeText(text) {
            return text
                .toLowerCase()
                .normalize("NFD") // Descomponer tildes
                .replace(/[\u0300-\u036f]/g, "") // Quitar tildes
                .replace(/[¿¡,.?]/g, ""); // Quitar puntuación
        }

        // --- 1. Carga de Datos (Automática) ---
        async function loadSheetData() {
            const urlProgramado = `${SHEETDB_BASE_URL}?sheet=PROGRAMADO`;
            const urlAutomatico = `${SHEETDB_BASE_URL}?sheet=AUTOMATICO`;
            
            console.log("Cargando datos...");
            try {
                const [resProgramado, resAutomatico] = await Promise.all([
                    fetch(urlProgramado),
                    fetch(urlAutomatico)
                ]);

                if (!resProgramado.ok || !resAutomatico.ok) {
                    throw new Error('No se pudo acceder a SheetDB. Revisa la URL o los nombres de las hojas (PROGRAMADO, AUTOMATICO).');
                }

                const jsonProgramado = await resProgramado.json();
                const jsonAutomatico = await resAutomatico.json();

                // Parsear datos programados (Pregunta, Respuesta)
                programadoData.clear();
                jsonProgramado.forEach(row => {
                    const pregunta = row.PREGUNTA || row.pregunta;
                    const respuesta = row.RESPUESTA || row.respuesta;
                    if (pregunta && respuesta) {
                        programadoData.set(normalizeText(pregunta), respuesta.trim());
                    }
                });

                // Parsear datos automáticos (Texto)
                automaticoData = jsonAutomatico
                    .map(row => {
                        const texto = row.TEXTO || row.texto;
                        return texto ? texto.trim() : null;
                    })
                    .filter(text => text && text.length > 0);

                isLoaded = true;
                console.log(`Datos cargados: ${programadoData.size} respuestas, ${automaticoData.length} palabras.`);
                
            } catch (error) {
                console.error("Error al cargar datos de SheetDB:", error);
                textDisplay.textContent = "Error de datos";
            }
        }

        // --- 2. Inicialización de Audio (Ruido, Blips) ---
        function initAudioContext() {
            if (audioContext) return;
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                // Ruido Blanco (Estática)
                whiteNoiseNode = audioContext.createBufferSource();
                const bufferSize = audioContext.sampleRate * 2; // 2 segundos
                const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
                const output = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    output[i] = Math.random() * 2 - 1;
                }
                whiteNoiseNode.buffer = buffer;
                whiteNoiseNode.loop = true;
                
                // Nodo de Ganancia (Volumen general)
                gainNode = audioContext.createGain();
                gainNode.gain.setValueAtTime(0, audioContext.currentTime);
                whiteNoiseNode.connect(gainNode).connect(audioContext.destination);
                whiteNoiseNode.start();

                // "Blip" del escáner
                blipOscillator = audioContext.createOscillator();
                blipGain = audioContext.createGain();
                blipOscillator.type = 'sine'; // Tono simple
                blipOscillator.frequency.setValueAtTime(1200, audioContext.currentTime); // Tono agudo
                blipGain.gain.setValueAtTime(0, audioContext.currentTime);
                blipOscillator.connect(blipGain).connect(audioContext.destination);
                blipOscillator.start();

            } catch (e) {
                console.error("Error al iniciar AudioContext:", e);
            }
        }

        // --- 3. Inicialización de Voz (Síntesis y Reconocimiento) ---
        function initSpeechModules() {
            // Cargar voces
            voices = synthesis.getVoices().filter(v => v.lang === 'es-MX');
            if (voices.length === 0) {
                voices = synthesis.getVoices().filter(v => v.lang.startsWith('es-'));
            }
            if (synthesis.onvoiceschanged !== undefined) {
                synthesis.onvoiceschanged = () => {
                    voices = synthesis.getVoices().filter(v => v.lang === 'es-MX');
                     if (voices.length === 0) {
                        voices = synthesis.getVoices().filter(v => v.lang.startsWith('es-'));
                    }
                };
            }

            // Configurar Reconocimiento
            if (!SpeechRecognition) {
                console.error("SpeechRecognition no es soportado en este navegador.");
                return;
            }
            try {
                recognition = new SpeechRecognition();
                recognition.lang = 'es-ES'; // Usar español general para mejor detección
                recognition.interimResults = false;
                recognition.continuous = false; // Escuchar de una en una

                recognition.onresult = (event) => {
                    clearTimeout(recognitionWatchdog); 
                    const transcript = event.results[0][0].transcript.trim();
                    isRecognizing = false; 
                    handleRecognitionResult(transcript);
                };

                recognition.onerror = (event) => {
                    clearTimeout(recognitionWatchdog); 
                    isRecognizing = false;
                    // Corrección: Esperar 1.5s antes de reintentar para no bloquear
                    if (isRunning && !isProgrammedResponse) {
                        setTimeout(startProgramadoMode, 1500);
                    }
                };

                recognition.onend = () => {
                    clearTimeout(recognitionWatchdog); 
                    isRecognizing = false;
                    // Reiniciar automáticamente
                    if (isRunning && !isProgrammedResponse && !synthesis.speaking) {
                        // FIX: Pausa de 1.5s para dar ventana al modo automático
                        setTimeout(startProgramadoMode, 1500); 
                    }
                };

            } catch (e) {
                console.error("Error al iniciar SpeechRecognition:", e);
                textDisplay.textContent = "Error de Mic";
            }
        }

        // --- 4. Funciones de Sonido ---
        
        // Estática
        function startNoise() {
            if (!audioContext) initAudioContext();
            audioContext.resume();
            gainNode.gain.linearRampToValueAtTime(0.07, audioContext.currentTime + 0.1);
        }
        function stopNoise() {
            if (gainNode) {
                gainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + 0.1);
            }
        }

        // Blip de frecuencia
        function playBlip() {
            if (!blipGain) return;
            const now = audioContext.currentTime;
            blipGain.gain.setValueAtTime(0, now);
            blipGain.gain.linearRampToValueAtTime(0.2, now + 0.01); // Ataque rápido
            blipGain.gain.linearRampToValueAtTime(0, now + 0.05); // Caída rápida
        }

        // Hablar (con efectos)
        function speak(text, isDistorted) {
            if (synthesis.speaking) {
                synthesis.cancel();
            }
            if (audioContext) audioContext.resume();

            if (crackleInterval) clearInterval(crackleInterval);

            const utterance = new SpeechSynthesisUtternance(text);
            
            // Priorizar voz es-MX
            utterance.voice = voices[0] || synthesis.getVoices().find(v => v.lang.startsWith('es-'));
            utterance.lang = utterance.voice ? utterance.voice.lang : 'es-ES';
            utterance.volume = 1; // Máximo volumen

            if (isDistorted) {
                // Efecto "fantasma" más natural
                utterance.pitch = Math.random() * 0.5 + 0.8; // Tono 0.8 a 1.3
                utterance.rate = Math.random() * 0.5 + 0.9;  // Velocidad 0.9 a 1.4

                if (gainNode) {
                    crackleInterval = setInterval(() => {
                        const crackleGain = Math.random() * 0.15 + 0.05; // Picos de 0.05 a 0.2
                        gainNode.gain.setValueAtTime(crackleGain, audioContext.currentTime);
                    }, 100);
                }
            } else {
                // Voz clara
                utterance.pitch = 1;
                utterance.rate = 1.0;
                if (gainNode) {
                    gainNode.gain.setValueAtTime(0.07, audioContext.currentTime);
                }
            }

            utterance.onstart = () => {
                textDisplay.textContent = text;
            };

            utterance.onend = () => {
                textDisplay.textContent = ''; // Limpiar display
                if (crackleInterval) clearInterval(crackleInterval);
                if (gainNode) {
                    gainNode.gain.linearRampToValueAtTime(0.07, audioContext.currentTime + 0.1);
                }

                // Si era una respuesta programada, reiniciar todo
                if (isProgrammedResponse) {
                    isProgrammedResponse = false;
                    startAllModes(); // Reiniciar ciclos
                }
            };
            
            synthesis.speak(utterance);
        }
        
        // --- 5. Lógica de Modos ---

        // Escaneo de Frecuencia
        function startFreqScan() {
            if (!isRunning) return;
            
            let freq = parseFloat(freqDisplay.textContent);
            freq += Math.random() * 0.4 + 0.1; // Salto aleatorio
            if (freq > 108.0) freq = 88.1;
            
            freqDisplay.textContent = freq.toFixed(1);
            playBlip();

            // Sincronizar con el slider (inverso, menos es más rápido)
            const scanSpeed = 1100 - baseDelay; // 100 (rápido) a 1000 (lento)
            freqTimeout = setTimeout(startFreqScan, scanSpeed);
        }
        
        // Modo Automático (Habla al azar)
        function startAutoMode() {
            if (!isRunning) return;
            
            // Delay basado en el slider
            const randomDelay = Math.random() * (baseDelay * 5) + (baseDelay * 2); // Ej: 600ms -> 1.2s a 4.2s
            
            autoTimeout = setTimeout(() => {
                // Hablar si: hay datos, no está hablando, no es una respuesta, y el mic no está escuchando
                if (automaticoData.length > 0 && !synthesis.speaking && !isProgrammedResponse && !isRecognizing) {
                    const randomIndex = Math.floor(Math.random() * automaticoData.length);
                    const word = automaticoData[randomIndex];
                    speak(word, true); // Hablar con distorsión
                }
                startAutoMode(); // Reiniciar ciclo
            }, randomDelay);
        }
        
        // Modo Programado (Escucha)
        function startProgramadoMode() {
            // No iniciar si ya está escuchando, hablando, o en medio de una respuesta
            if (!isRunning || !recognition || isRecognizing || synthesis.speaking || isProgrammedResponse) {
                return;
            }

            clearTimeout(recognitionWatchdog);

            try {
                isRecognizing = true;
                recognition.start();

                // Watchdog: Si se congela por 8 seg, forzar reinicio.
                recognitionWatchdog = setTimeout(() => {
                    if (isRecognizing) { 
                        console.error("Speech recognition watchdog triggered: Forcing restart.");
                        isRecognizing = false;
                        recognition.stop(); // Esto disparará 'onend', que reiniciará el ciclo
                    }
                }, 8000); 

            } catch (e) {
                isRecognizing = false;
                // console.error("Error al iniciar reconocimiento:", e);
                // Reintentar si falla (ej. "already started")
                if (isRunning) {
                    setTimeout(startProgramadoMode, 1500); // Esperar 1.5s
                }
            }
        }
        
        // Manejar resultado del micrófono
        function handleRecognitionResult(transcript) {
            const normalizedTranscript = normalizeText(transcript);
            
            if (programadoData.has(normalizedTranscript)) {
                // --- ¡MATCH! ---
                isProgrammedResponse = true; // Poner en pausa los ciclos
                synthesis.cancel(); // Cancelar cualquier voz automática
                clearTimeout(autoTimeout); // Detener ciclo automático
                clearTimeout(freqTimeout); // Detener ciclo de frecuencia
                
                const response = programadoData.get(normalizedTranscript);
                speak(response, false); // Hablar claro
                
            } else {
                // --- NO MATCH ---
                // No hacer nada, el ciclo 'onend' reiniciará la escucha
            }
        }

        // Limpiar todos los ciclos
        function clearAllTimeouts() {
            clearTimeout(autoTimeout);
            clearTimeout(freqTimeout);
            clearTimeout(recognitionWatchdog);
            if (crackleInterval) clearInterval(crackleInterval);
        }

        // Función central para (re)iniciar los modos
        function startAllModes() {
            // Corrección: Asegurarse de limpiar todo antes de empezar
            clearAllTimeouts();
            
            if (!isRunning) return;
            
            startFreqScan();
            startAutoMode();
            startProgramadoMode();
        }

        // --- 6. Event Listeners ---
        
        btnPower.addEventListener('click', () => {
            isRunning = !isRunning;
            
            if (isRunning) {
                // --- ENCENDER ---
                btnPower.textContent = "APAGAR";
                btnPower.classList.remove('off');
                btnPower.classList.add('on');
                
                if (!isLoaded) {
                    textDisplay.textContent = "Error de datos";
                    return;
                }
                
                initAudioContext();
                initSpeechModules();
                startNoise();
                startAllModes(); // Iniciar todos los ciclos

            } else {
                // --- APAGAR ---
                btnPower.textContent = "ENCENDER";
                btnPower.classList.remove('on');
                btnPower.classList.add('off');
                
                // Detener todo
                stopNoise();
                synthesis.cancel();
                if (recognition) recognition.stop();
                clearAllTimeouts();
                
                textDisplay.textContent = '';
                freqDisplay.textContent = '88.1';
            }
        });
        
        speedSlider.addEventListener('input', (e) => {
            // Invertir el valor (slider a la derecha = más lento = delay más alto)
            baseDelay = 1100 - parseInt(e.target.value, 10);
        });

        // Carga inicial
        window.onload = () => {
            loadSheetData();
        };

    </script>
</body>
</html>
